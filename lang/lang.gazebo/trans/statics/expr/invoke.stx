module statics/expr/invoke

imports

    statics/common
    statics/expr
    statics/types
    statics/type/bounds

rules

    typeOfInvoke : scope * Invoke -> TYPE

    typeOfInvoke(s, InvokeNone(Expr2Expr-I(e))) = Tr :- {Tfn}
        typeOfExpr(s, e) == Tfn,
        typeOfInvoke_internal(s, Tfn, Args([])) == Tr | error $[cannot invoke, type [Tfn] is not a function]@e.

    typeOfInvoke(s, InvokeArgs(Expr2Expr-I(e), a)) = Tr :- {Tfn}
        typeOfExpr(s, e) == Tfn,
        typeOfInvoke_internal(s, Tfn, a) == Tr | error $[cannot invoke, type [Tfn] is not a function]@e.

rules

    typeOfInvoke_internal : scope * TYPE * Args -> TYPE

    typeOfInvoke_internal(s, FUNC(Tparams, Tr), a) = Tr :- {Tparams_remaining}
        funcArgsOk(s, Tparams, a) == Tparams_remaining.

rules

    funcArgsOk : scope * list((ID * TYPE)) * Args -> list((ID * TYPE))

    funcArgsOk(_, [], Args(args@[_|_])) = [] :-
        false | error $[too many positional arguments given]@args.

    funcArgsOk(_, params, Args([])) = params.

    funcArgsOk(s, [(name, Tpar) | xs], Args([Expr2Expr-I(e) | ys])) = funcArgsOk(s, xs, Args(ys)) :- {Te}
        Te == typeOfExpr(withTypeInject(s, Tpar), e),
        subtype(Te, Tpar) | error $[expression type not suitable for parameter of type [Tpar]]@e.
