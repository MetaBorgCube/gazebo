language llmc
module syntax/experiments

test experiment 1 [[[
function exp:a

global dummy iS = data example:abc/def '"Path" "to" "some thing"[0]'

sign _ret iS

local a r[minecraft:block]
local b @
local c iI

body {
    a <- r[minecraft:block, minecraft:chest]+[facing="south", waterlogged=0B][c[
        "Items" l[c[
            "Slot" 0B,
            "id" r[minecraft:item, minecraft:stone],
            "Count" 64B
        ]]
    ]]
    b <- @r[level=7I]
    c <- |[(default) "say hello"]
    dummy <- 0B
    _ret <- 1B
}
]]] parse succeeds

test experiment 2 from actual gzb source [[[[
function a:b/very_first_test

local a s
local c s
local $if_not_taken1 iB
local .const idx s
local .const two s
local b s
local $arith2 s
local $rv_from_lv1 s
local $find2 s
local $arith3 s
local $invoke1 s
local .const nbt_var_const s
local nbt_var_dyn s
local $find3 s

body
    {
        a <- 0I
        c <- 3I
    }
    {
        {
            $if_not_taken1 <- 1B
        }
        if 1I <= c {
            {
                $if_not_taken1 <- 0B
            }
            {
                a <- 5I
                idx <- 0I
                two <- 2I
                $arith2 <- add 1I two
                b <- l[$arith2]
                $rv_from_lv1 <- find b '[0]'
                b, '[0]' <- add $rv_from_lv1 6I
                $find2 <- find b '[0]'
                a <- $find2
            }
        }
        if $if_not_taken1 = 1B {
        }
    }
    {
        $arith3 <- add 2I 3I
        $invoke1 <- ivk a:b/other $arith3
        _ <- $invoke1
        nbt_var_const <- c["a" 4I, "b" l["World!"], "my key" a[3I, 4I, 5I], "bool" 1B]
        $find3 <- find nbt_var_const '"b" [0]'
        nbt_var_dyn <- c["a" a, "b" l["Hello ", $find3], "nested" c["other\" key" a[c]]]
    }
]]]] parse succeeds
