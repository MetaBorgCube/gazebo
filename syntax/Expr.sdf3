module Expr

imports

    Common
    NBT
    Selector
    TagAndResource
    Literals
    Type
    NSID

context-free sorts

    Expr
    Expr-I // internal (possibly bracketed) expression
    // TODO: Avoid usage of this Expr-I, instead prefer Expr.Invoke over bracketing (question is how)

/**
 * Basic expressions
 */
context-free syntax

    Expr-I = Expr
    Expr-I = <(<Expr-I>)> {bracket}
    
    // from imports:
    Expr = NBT
    Expr = Selector
    Expr = Tag
    Expr = Resource
    Expr = Literal

/**
 * Reference
 */
context-free sorts Ref
context-free syntax

    Expr = Ref
    Ref.Ref = NSID

/**
 * Find
 */
context-free sorts Find
context-free syntax

    Expr = Find
    Find.FindIndex = <<Expr-I>[<Expr-I>]>
    Find.FindPathID = <<Expr-I>.<ID>>
    Find.FindPathString = <<Expr-I>.<STRING>>

    // prevent any selector (e.g. @a[level>4]) to be interpreted as an index find
    Find = <<Selector>[<Expr-I>]> {reject}

/**
 * Static find (meant for enum references)
 */
context-free sorts FindStatic
context-free syntax

    Expr = FindStatic
    FindStatic.FindStaticID = <<Expr-I>::<ID>>

/**
 * Invoke
 */
context-free sorts Invoke Args Kwargs Kwarg
context-free syntax

    Expr = Invoke
    Invoke.InvokeNone = <<Expr-I>()>
    Invoke.InvokeArgs = <<Expr-I>(<Args>)>
    Invoke.InvokeArgsKwargs = <<Expr-I>(<Args>, <Kwargs>)>
    Invoke.InvokeKwargs = <<Expr-I>(<Kwargs>)>
    Args.Args = <<{Expr-I ", "}+>>
    Kwargs.Kwargs = <<{Kwarg ", "}+>>
    Kwarg.Kwarg = <<ID>=<Expr-I>>

/**
 * Arithmetic
 */
context-free syntax

    Expr.Mul = <<Expr-I> * <Expr-I>> {left}
    Expr.Div = <<Expr-I> / <Expr-I>> {left}
    Expr.Mod = <<Expr-I> % <Expr-I>> {left}

    Expr.Add = <<Expr-I> + <Expr-I>> {left}
    Expr.Sub = <<Expr-I> - <Expr-I>> {left}

/**
 * Boolean operations
 */
context-free sorts Compare
context-free syntax

    Expr.And = <<Expr-I> and <Expr-I>> {non-assoc}
    Expr.Or = <<Expr-I> or <Expr-I>> {non-assoc}

    Expr.Not = <not <Expr-I>>

    Expr.Cmp = <<Expr-I> <Compare> <Expr-I>> {non-assoc}
    Compare.CmpGt = [>]
    Compare.CmpGte = [>=]
    Compare.CmpLt = [<]
    Compare.CmpLte = [<=]
    Compare.CmpEqual = [==]
    Compare.CmpEquiv = [eq] 
    Compare.CmpIs = [is]
    Compare.CmpMatches = [matches]

lexical syntax

    ID = "eq" {reject}
    ID = "is" {reject}
    ID = "matches" {reject}

/**
 * Range
 */
context-free sorts Range
context-free syntax

    Expr = Range
    Range.RangeFull = <<Expr-I>..<Expr-I>>

/**
 * Position/vector
 */
context-free sorts Vec VecElem
context-free syntax

    Expr = Vec
    Vec.Vec = <`(<VecElem> <VecElem> <VecElem>)>
    VecElem.VecElemAbs = [ [Expr]]
    VecElem.VecElemRel = [~[Expr?]]
    VecElem.VecElemLoc = [^[Expr?]]

////////

context-free priorities

    {
        Find.FindIndex
        Find.FindPathID
        Find.FindPathString
        FindStatic.FindStaticID
    } > {
        Invoke.InvokeNone
        Invoke.InvokeArgs
        Invoke.InvokeArgsKwargs
        Invoke.InvokeKwargs
    } > {
        left:
        Range.RangeFull
    } > {
        Expr.Cmp
    } > {
        left:
        Expr.Mul
        Expr.Div
        Expr.Mod
    } > {
        Expr.Not
    } > {
        left:
        Expr.Add
        Expr.Sub
    } > {
        left:
        Expr.And
    } > {
        left:
        Expr.Or
    }



