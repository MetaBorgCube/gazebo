module type-access

imports

  signatures/llmc/-
  // BUG: this would have been sufficient (below), but transitive imports are not so great for source deps apparently
  signatures/-

  common
  type

  str_common

signature

  sorts Hole
  constructors
    HoleMk : Type-LL -> Hole
    HoleRef : Hole
    HoleCommon : Hole

strategies // type-access-path(|Path-LL) :: Type-LL -> Type-LL

  type-access-path(|Path-LL([])) = id
  type-access-path(|Path-LL(elems)) =
    !(elems, <id>)
  ; foldl(type-access-path-elem)

rules // type-access-path-elem :: (PathElem-LL, Type-LL) -> Type-LL

  type-access-path-elem: (Select-LL(key), t) -> <type-access-compound(|key)> t
  type-access-path-elem: (IndexFix-LL(_), t) -> <type-access-list_array> t
  type-access-path-elem: (IndexDyn-LL(_), t) -> <type-access-list_array> t

rules // type-access-compound(|key) :: Type-LL -> Type-LL

  type-access-compound(|key): t@TypeCompound-LL(None(), entries) -> t'
    with
      t' := <fetch-elem(?TypeCompoundEntry-LL(key, <id>))> entries
  type-access-compound(|key): t@TypeCompound-LL(Some(TypeRefCreate-LL(ident)), entries)
    -> <ta--normalize(|[(ident, t)])> t'
    with
      t' := <fetch-elem(?TypeCompoundEntry-LL(key, <id>))> entries

rules // type-access-list_array :: Type-LL -> Type-LL

  type-access-list_array: TypeList-LL(None(), t') -> t'
  type-access-list_array: TypeArray-LL(None(), t') -> t'
  type-access-list_array: t@TypeList-LL(Some(TypeRefCreate-LL(ident)), t')
    -> <ta--normalize(|[(ident, t)])> t'
  type-access-list_array: t@TypeArray-LL(Some(TypeRefCreate-LL(ident)), t')
    -> <ta--normalize(|[(ident, t)])> t'

strategies // ta--normalize(|Env) :: Type-LL -> Type-LL

  ta--normalize(|env) =
    ta--expand(|env)
  ; repeat(ta--contract; type-clean)

strategies // ta--expand(|Env) :: Type-LL -> Type-LL

  /** Expand all references, given an origin environment. */
  ta--expand(|env) =
    bottomup(try(
      \TypeRef-LL(ident) -> <fetch-elem(where(Fst; ?ident)); Snd> env\
    ))

strategies

  ta--contract = ?o
  ; with(
      collect-all(
        (?TypeList-LL(Some(TypeRefCreate-LL(<id>)), _) + ?TypeArray-LL(Some(TypeRefCreate-LL(<id>)), _) + ?TypeCompound-LL(Some(TypeRefCreate-LL(<id>)), _))
        , conc
      ) => origins
      // assert that all found reference numbers are distinct
    ; with(is-distinct)
    )
  ; !origins
    // compute the next available reference number, and store it as a string
  ; with(j := <map(string-to-int); list-max; !(<id>, 1); addi; int-to-string>)
    // attempt to contract a reference, starting from the first
  ; fetch-elem(\i -> <ta--contract(|i, j)> o\)

/*
  Rough algorithm:
    1. replace decl with hole and get parent
       - add "j" to tree in-place
    2. convert all relevant TypeRef-LL to hole
    3. collect all hole parents
    4. ensure they all overlap (by temporarily replacing all Holes with HoleCommon)
*/
  ta--contract(|i, j): o -> res
    where
      o_holes := <
        // reference holes
        topdown(try(\TypeRef-LL(i) -> HoleRef()\))
        // origin holes
      ; oncetd(
          ( ?TypeList-LL(Some(TypeRefCreate-LL(i)), _)
          + ?TypeArray-LL(Some(TypeRefCreate-LL(i)), _)
          + ?TypeCompound-LL(Some(TypeRefCreate-LL(i)), _)
          )
        ; !HoleMk(<id>)
        )
      > o
      // lookup the parent of the origin
    ; parent_origin := <ta--parents-of(?HoleMk(_)); ?[<id>]> o_holes
      // attach the new reference number to origin's parent,
      // and remove the temporary HoleMk holder
    ; o_holes_newparent := <ta--at-parents-of(?HoleMk(_), ta--ref-insert(|j); topdown(try(?HoleMk(<id>))))> o_holes
      // lookup all parents of reference holes
    ; parents_ref := <ta--parents-of(?HoleRef())> o_holes_newparent
      // rewrite all reference holes to using the new reference index
    ; res := <ta--at-parents-of(?HoleRef(), !TypeRef-LL(j))> o_holes_newparent
  where // only succeed if all hole parents are equivalent, i.e. have a common structure
    !([parent_origin], parents_ref)
  ; ta--hole-common
  ; all(make-set(type-compat))
  ; union(type-compat)
  ; ?[_]

strategies // AUX

  /** Retrieve a list of the terms for whose which strategy 's' succeeds on at least one of its children. */
  ta--parents-of(s) = rec x({ parent
  : ?parent
  ; (ta--children <+ ![])
  ; (
      where(fetch-elem(s))
    ; ![parent]
   <+ map(x)
    ; flatten-list
    )
  })

  /** Execute s_transform at the parent term in case s_check succeeds for at least one child.
   * Continues in top-down fashion. */
  ta--at-parents-of(s_check, s_transform) = rec x(
    where(ta--children; fetch-elem(s_check))
  ; s_transform
 <+ all(x)
  )

  /** Get all type children, if avaialable, as a list. */
  ta--children = ?TypeList-LL(_, <![<id>]>)
  ta--children = ?TypeArray-LL(_, <![<id>]>)
  ta--children = ?TypeCompound-LL(_, <map(?TypeCompoundEntry-LL(_, <id>))>)

  ta--ref-insert(|j) = TypeList-LL(!Some(TypeRefCreate-LL(j)), id)
  ta--ref-insert(|j) = TypeArray-LL(!Some(TypeRefCreate-LL(j)), id)
  ta--ref-insert(|j) = TypeCompound-LL(!Some(TypeRefCreate-LL(j)), id)

  /** Enforce all holes to be HoleCommon. */
  ta--hole-common = topdown(try(
    (?HoleMk(_) + ?HoleRef())
  ; !HoleCommon()
  ))
