module transform

imports

  signatures/llmc/-
  signatures/-

  common

  // BUF: transitive from 'common', but included here because otherwise the eclipse editor complains
  str_common

signature

  /** variable location specifier */
  sorts Loc
  constructors
    /** variable on the local stack */
    StackKey : string -> Loc
    /** variable in the data storage, identified by the namespace with name and an access path */
    DataStorage : NSID * Path-LL -> Loc

strategies // transform-function :: Function-LL -> Unit-ASM

  transform-function =
    ?Function-LL(_, decls, Body-LL(body_block))
  ; {| VarLoc
    : <map(register-decl)> decls
    ; <transform-block> body_block
    |}

strategies // register-decl :: Decl-LL -> _

  register-decl =
    ?Decl-LL(scope, mods, name, _, loc)
  ; loc' := <register-decl-loc(|name)> loc
  ; rules(VarLoc: name -> loc')

  register-decl-loc(|name): StorageLocationAuto-LL() -> StackKey(name)
  register-decl-loc(|_): StorageLocationData-LL(nsid, path) -> DataStorage(<transform-nsid> nsid, path)

rules // transform-nsid :: NSID-LL -> NSID

  transform-nsid: NSID-LL(ns, name) -> NSID(ns, name)

rules // data-loc-args(|path_ext) :: string -> List(Arg-ASM)

  data-loc-args = data-loc-args(|Path-LL([]))

  norm-loc-to-data-storage: StackKey(key) ->
    DataStorage(
      NSID("gzb", ["_internal"]),
      Path-LL([
        Select-LL(<string-denorm> "_stack"),
        IndexFix-LL("-1"),
        Select-LL(<string-denorm> key)
      ])
    )

  data-loc-args(|path_ext): var -> args
    with
      loc@DataStorage(nsid, path_base) := <VarLoc; try(norm-loc-to-data-storage)> var
    ; args := [
        Arg-RawString-ASM("storage"),
        Arg-NSID-ASM(nsid),
        <path-join; transform-path> [path_base, path_ext]
      ]

rules // scoreboard-loc-args :: string -> List(Arg-ASM)

  scoreboard-loc-args: var -> dest*
    with
      data_loc* := <data-loc-args> var
    ; player_ident := <newname> "uuidv4_TODO"
    ; dest* := [
        Arg-RawString-ASM(player_ident),
        Arg-RawString-ASM("gzb")
      ]
    ; rules(EmitCommand-Pre:+ _ -> Command-Plain-ASM(
        "execute",
        [
          Arg-RawString-ASM("store"),
          Arg-RawString-ASM("result"),
          Arg-RawString-ASM("score"),
          dest*,
          Arg-RedirectSelf-ASM([
            Arg-RawString-ASM("run"),
            Arg-Redirect-ASM(Command-Plain-ASM(
              "data",
              [
                Arg-RawString-ASM("get"),
                data_loc*
                // could add scaling factor here in float support mode
              ]
            ))
          ])
        ]
      ))

rules // transform-block :: Block-LL -> Unit-ASM

  transform-block: FlowGroup-LL(flow_block*) -> Unit-ASM(flow_block'*)
    with
      flow_block'* := <map-with-emitted-commands(transform-flow-block)> flow_block*
  transform-block: BasicBlock-LL(assign*) -> Unit-ASM(assign'*)
    with
      assign'* := <map-with-emitted-commands(transform-assign)> assign*

  map-with-emitted-commands(s-trans) =
    map({| EmitCommand-Pre, EmitCommand-Post
      // workaround to enforce "empty" dr rhs set
      // see https://slde.slack.com/archives/C7254SF60/p1640029435083900
      : with(rules(EmitCommand-Pre:+ _ -> <fail>))
      ; with(rules(EmitCommand-Post:+ _ -> <fail>))
      ; s-trans
      ; ![<bagof-EmitCommand-Pre; reverse <+ ![]>(), [<id>], <bagof-EmitCommand-Post; reverse <+ ![]>()]
      ; concat
      |})
  ; flatten-list

rules // transform-flow-block :: FlowBlock-LL -> Command-ASM

  transform-flow-block: FlowBlock-LL(Unconditional-LL(), _, block) -> Command-AnonSubUnit-ASM(block')
    with
      block' := <transform-block> block

  // TODO: loop

  transform-flow-block: FlowBlock-LL(If-LL(ArgCond-LL(cond)), _, block) ->
    Command-Plain-ASM("execute", [
      cond*,
      Arg-RedirectSelf-ASM([
        Arg-RawString-ASM("run"),
        Arg-Redirect-ASM(Command-AnonSubUnit-ASM(block'))
      ])
    ])
    with
      cond* := <transform-cond-exec> cond
    ; block' := <transform-block> block

rules // transform-cond-exec :: BoolCond-LL -> List(Arg-ASM)

  transform-cond-exec: BoolCondCmp-LL(ArgVar-LL(lhs_var), cmp, ArgVar-LL(rhs_var)) ->
    [
      Arg-RawString-ASM("if"),
      Arg-RawString-ASM("score"),
      lhs*,
      Arg-RawString-ASM(<
        \CmpLt-LL() -> "<"\
      + \CmpLte-LL() -> "<="\
      + \CmpEq-LL() -> "="\
      + \CmpGt-LL() -> ">"\
      + \CmpGte-LL() -> ">="\
      > cmp),
      rhs*
    ]
    with
      lhs* := <scoreboard-loc-args> lhs_var
    ; rhs* := <scoreboard-loc-args> rhs_var

  // if lhs is not ArgVar, but rhs is, flip and try again
  transform-cond-exec =
    ?BoolCondCmp-LL(lhs, cmp, rhs@ArgVar-LL(_))
  ; !lhs; not(?ArgVar-LL(_))
  ; cmp_inv := <
      \CmpLt-LL() -> CmpGt-LL()\
    + \CmpLte-LL() -> CmpGte-LL()\
    + \CmpEq-LL() -> CmpEq-LL()\
    + \CmpGt-LL() -> CmpLt-LL()\
    + \CmpGte-LL() -> CmpLte-LL()\
    > cmp
  ; !BoolCondCmp-LL(rhs, cmp_inv, lhs)
  ; transform-cond-exec

  transform-cond-exec: BoolCondCmp-LL(ArgVar-LL(lhs_var), cmp, num) ->
    [
      Arg-RawString-ASM("if"),
      Arg-RawString-ASM("score"),
      lhs*,
      Arg-RawString-ASM("matches"),
      Arg-RawString-ASM(<concat-strings> [range_prefix, <int-to-string> v_int', range_suffix])
    ]
    where
      // TODO: warn about long
      !num; is-int-ll => v
    with
      lhs* := <scoreboard-loc-args> lhs_var
    with
      v_int := <string-to-int> v
    ; (range_prefix, range_suffix, v_int') := <
        \CmpLt-LL() -> ("..", "", <subti> (v_int, 1))\
      + \CmpLte-LL() -> ("..", "", v_int)\
      + \CmpEq-LL() -> ("", "", v_int)\
      + \CmpGt-LL() -> ("", "..", <addi> (v_int, 1))\
      + \CmpGte-LL() -> ("", "..", v_int)\
      > cmp

  // TODO: move this to separate phase
  transform-cond-exec: BoolCondCmp-LL(lhs, cmp, rhs) -> args
    where
      !lhs; is-numeric-ll => lhs_v
    ; !rhs; is-numeric-ll => rhs_v
    with
      [lhs_v_num, rhs_v_num] := <map(string-to-int <+ string-to-real)> [lhs_v, rhs_v]
    ; if <eval-cmp-numeric(|cmp)> (lhs_v_num, rhs_v_num) then
        // true emulation, no args mean it always flows through
        args := []
      else
        // false emulation
        args := [
          Arg-RawString-ASM("unless"),
          Arg-RawString-ASM("entity"),
          Arg-RawString-ASM("@e")
        ]
      end
  eval-cmp-numeric(|CmpLt-LL()) = lt
  eval-cmp-numeric(|CmpLte-LL()) = leq
  eval-cmp-numeric(|CmpEq-LL()) = eq
  eval-cmp-numeric(|CmpGt-LL()) = gt
  eval-cmp-numeric(|CmpGte-LL()) = geq

rules // transform-assign :: Assign-LL -> Command-ASM

  transform-assign: AssignOp-LL(dest, op, arg*) -> "TODO: op"

  transform-assign: AssignNew-LL(DestDiscard-LL(), _) -> Command-NoOp-ASM()

  // overload for usage of AssignNew-LL(DestVar-LL(_), _)
  // only works as long as all variables actually support path access
  transform-assign =
    AssignNew-LL(\DestVar-LL(var){anno*} -> DestVarPath-LL(var, Path-LL([])){anno*}\, id)
  ; transform-assign

  transform-assign: AssignNew-LL(DestVarPath-LL(var, path), <is-new-compatible => arg>) ->
    Command-Plain-ASM("data", [
      Arg-RawString-ASM("modify"),
      dest_loc*,
      Arg-RawString-ASM("set"),
      Arg-RawString-ASM("value"),
      Arg-RawString-ASM(value)
    ])
    with
      dest_loc* := <data-loc-args(|path)> var
    ; value := <transform-assign-new-arg(|var, path); opt-unwrap(!"$placeholder"; string-denorm)> arg

  transform-assign: _ -> <fail>
    with
      err(|"Assign not recognized, is partial evaluation OK?")

rules // transform-assign-new-arg(|Path-LL) :: Arg-LL -> Optional(string)

  transform-assign-new-arg(|_, _): ArgString-LL(str) -> Some(str)
  transform-assign-new-arg(|_, _): ArgIntB-LL(int) -> Some(<concat-strings> [int, "b"])
  transform-assign-new-arg(|_, _): ArgIntS-LL(int) -> Some(<concat-strings> [int, "s"])
  transform-assign-new-arg(|_, _): ArgIntI-LL(int) -> Some(int)
  transform-assign-new-arg(|_, _): ArgIntL-LL(int) -> Some(<concat-strings> [int, "L"])
  transform-assign-new-arg(|_, _): ArgFloatS-LL(float) -> Some(float)
  transform-assign-new-arg(|_, _): ArgFloatD-LL(float) -> Some(<concat-strings> [float, "d"])

  transform-assign-new-arg(|v, p): ArgList-LL(elems*) -> Some(<concat-strings> ["[", elems'*, "]"])
    with
      elems'* := <enumerate-map-intersperse({p':
        with(p' := <Fst; int-to-string; ![p, Path-LL([IndexFix-LL(<id>)])]; path-join>)
      ; Snd
      ; transform-assign-new-arg(|v, p')
      ; opt-unwrap(!"0")
      })> elems*

  transform-assign-new-arg(|v, p): ArgArray-LL(elems*) -> Some(<concat-strings> ["[", type, "; ", elems'*, "]"])
    with
      type := "TODO_Array_Type"
    ; elems'* := <enumerate-map-intersperse({p':
        with(p' := <Fst; int-to-string; ![p, Path-LL([IndexFix-LL(<id>)])]; path-join>)
      ; Snd
      ; transform-assign-new-arg(|v, p')
      ; opt-unwrap(!"0") // TODO: use correct placeholder based on array type
      })> elems*

  transform-assign-new-arg(|v, p): ArgCompound-LL(entries) -> Some(<concat-strings> ["{", entries'*, "}"])
    with
      entries'* := <
        map(
          // also don't need to denorm this key because it's already in denorm form
          {p': \CompoundEntry-LL(key, value) ->
            [key, ": ", <transform-assign-new-arg(|v, p'); opt-unwrap(!"$placeholder"; string-denorm)> value]
            with
              p' := <path-join> [p, Path-LL([Select-LL(key)])]
          \}
        ; concat-strings
        )
      ; intersperse(|", ")
        > entries

  transform-assign-new-arg(|v, p): ArgVar-LL(var) -> None()
    with
      dest_loc* := <data-loc-args(|p)> v
    ; src_loc* := <data-loc-args> var
    ; rules(EmitCommand-Post:+ _ -> Command-Plain-ASM(
        "data", [
          Arg-RawString-ASM("modify"),
          dest_loc*,
          Arg-RawString-ASM("set"),
          Arg-RawString-ASM("from"),
          src_loc*
        ])
      )

  transform-assign-new-arg(|_, _): ArgRaw-LL(_) -> None() // TODO: raw
  transform-assign-new-arg(|_, _): ArgUnsafe-LL(_) -> None() // TODO: unsafe
  transform-assign-new-arg(|_, _): ArgUnsafe-LL(_) -> None() // TODO: cond

rules // transform-path :: Path-LL -> Arg-ASM

  transform-path: Path-LL(elems) -> Arg-RawString-ASM(str)
    with
      str := <foldl(
        \(elem, "") -> <transform-path-fold(id)> elem\
     <+ \(elem, accum) -> <concat-strings> [accum, <transform-path-fold(fail)> elem]\
      )> (elems, "")

  // key is already in denorm form
  transform-path-fold(is-first): Select-LL(key) -> <concat-strings> [prefix, key]
    with
      if is-first then
        prefix := ""
      else
        prefix := "."
      end

  transform-path-fold(is-first): IndexFix-LL(idx) -> <concat-strings> ["[", idx, "]"]

  // TODO: Filter-LL
