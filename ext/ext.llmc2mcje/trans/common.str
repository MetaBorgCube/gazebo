module common

imports

  signatures/llmc/-
  // BUG: this would have been sufficient (below), but transitive imports are not so great for source deps apparently
  signatures/-

  libspoofax/-

  libstratego-gpp

  str_common

signature

  sorts NSID
  constructors
    NSID : string * List(string) -> NSID

  sorts Unit-ASM Command-ASM Arg-ASM
  constructors
    /** base unit */
    Unit-ASM : List(Command-ASM) -> Unit-ASM
    /** plain command, without formatting */
    Command-Plain-ASM : string * List(Arg-ASM) -> Command-ASM
    /** call with GZB calling convention */
    Command-CallGzb-ASM : NSID * List(string) -> Command-ASM
    /** anonymous sub-unit (assembled in new function file x:y/z, expanded to 'function x:y/z') */
    Command-AnonSubUnit-ASM : Unit-ASM -> Command-ASM
    /** no-op */
    Command-NoOp-ASM : Command-ASM
    /** command self-redirection (e.g. 'execute if abc' -> 'if xyz'), mainly used for execute chains */
    Arg-RedirectSelf-ASM : List(Arg-ASM) -> Arg-ASM
    /** general command redirection (e.g. 'execute ... run' -> 'say hi') */
    Arg-Redirect-ASM : Command-ASM -> Arg-ASM
    /** generic NSID arg */
    Arg-NSID-ASM : NSID -> Arg-ASM
    /** raw string part, anything allowed */
    Arg-RawString-ASM : string -> Arg-ASM

strategies

  intersperse-concat(|sep) =
    with(all(not(is-list)))
  ; intersperse(|sep)
  ; concat-strings

strategies

  path-join =
    map(?Path-LL(<id>))
  ; concat
  ; !Path-LL(<id>)

strategies

  is-int-ll =
    ( ?ArgIntB-LL(v)
    + ?ArgIntS-LL(v)
    + ?ArgIntI-LL(v)
    + ?ArgIntL-LL(v)
    )
  ; !v

  is-float-ll =
    ( ?ArgFloatS-LL(v)
    + ?ArgFloatD-LL(v)
    )
  ; !v

  is-numeric-ll = is-int-ll + is-float-ll

  is-lit-nbt-compatible =
    ?ArgString-LL(_)
  + ?ArgIntB-LL(_)
  + ?ArgIntS-LL(_)
  + ?ArgIntI-LL(_)
  + ?ArgIntL-LL(_)
  + ?ArgFloatS-LL(_)
  + ?ArgFloatD-LL(_)
  + ArgList-LL(all(is-lit-nbt-compatible))
  + ArgArray-LL(all(is-lit-nbt-compatible))
  + ArgCompound-LL(all(CompoundEntry-LL(id, is-lit-nbt-compatible)))

rules // nbt-to-string :: Arg-LL -> string

  // don't need to denorm the str value because it is already in denorm form
  nbt-to-string: ArgString-LL(str) -> str
  nbt-to-string: ArgIntB-LL(int) -> <concat-strings> [int, "b"]
  nbt-to-string: ArgIntS-LL(int) -> <concat-strings> [int, "s"]
  nbt-to-string: ArgIntI-LL(int) -> int
  nbt-to-string: ArgIntL-LL(int) -> <concat-strings> [int, "L"]
  nbt-to-string: ArgFloatS-LL(float) -> float
  nbt-to-string: ArgFloatD-LL(float) -> <concat-strings> [float, "d"]
  nbt-to-string: ArgList-LL(elems*) -> <concat-strings> ["[", elems'*, "]"]
    with
      elems'* := <map(nbt-to-string); intersperse(|", ")> elems*
  nbt-to-string: ArgArray-LL(elems*) -> <concat-strings> ["[", type, "; ", elems'*, "]"]
    with
      type := "TODO_Array_Type"
    ; elems'* := <map(nbt-to-string); intersperse(|", ")> elems*
  nbt-to-string: ArgCompound-LL(entries) -> <concat-strings> ["{", entries'*, "}"]
    with
      entries'* := <
        map(
          // also don't need to denorm this key because it's already in denorm form
          \CompoundEntry-LL(key, value) -> [key, ": ", <nbt-to-string> value]\
        ; concat-strings
        )
      ; intersperse(|", ")
        > entries
