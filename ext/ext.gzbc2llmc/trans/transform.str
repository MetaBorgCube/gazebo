module transform

imports

  signatures/gazebo-core/-
  signatures/llmc/-
  signatures/-

  common
  transform-execute
  transform-type
  type-ctype
  type-access

  // BUG: transitive from 'common', but included here because otherwise the eclipse editor complains
  str_common

rules // transform-tlis(|base) :: List(Tli-C) -> List(Function-LL)

  transform-tlis(|base) = {| RefType
    // register types of global references used in this file
  : all(try(where(
      \TypeofGlobal-C(<strip-annos => identf>, <strip-annos => t>) -> <rules(RefType:+ RefFull-C(identf) -> t)>\
    )))
  ; filter(not(?TypeofGlobal-C(_, _)))
  ; map(transform-tli(|base))
  |}

rules // transform-tli(|base) :: Tli-C -> Function-LL

  transform-tli(|base): Function-C(tags, name, Signature-C(params, t_ret), block) ->
    Function-LL(
      <nsid-from-base(|base)> name,
      tags',
      decls,
      Body-LL(block')
    )
    with
      // Transform tags
      tags' := <map(\Tag-C(tag_identf) -> TagRegistration-LL(<nsid-from-identf> tag_identf)\)> tags
      // Scoped transformation of parameters and body
    ; {| RefType, RegisterDecl, GlobalLookup
        // make sure all parameters are registered in scope
      : <map(
          \Param-C(_, <strip-annos => name>, <strip-annos => t>) -> <rules(RefType:+ RefLocal-C(IdentLocal-C(name)) -> t)>\
        )> params
      ; block' := <transform-block> block
      ; decl_gen* := <bagof-RegisterDecl; reverse <+ ![]>()
      |}
      // Collect declarations corresponding to the signature
    ; decl_sign* := <map({t': \Param-C(kind, name, t) -> Decl-LL(SSign-LL(), mod*, name, t', StorageLocationAuto-LL())
        with
          mod* := <
            \ParamKindConst-C() -> [ModConst-LL()]\
         <+ ![]
          > kind
        ; t' := <transform-type> t
      \})> params
      // Gather all decls
    ; decls := [decl_sign*, decl_gen*]

  transform-tli(|base@[ns|basename]): Decl-C(_, name, _, e) ->
    Function-LL(
      <newname; ![name, <id>]; nsid-from-base(|base)> "_global.init",
      [
        // Register the global initializer to be run upon world init
        // TODO: guarantee initialization order
        TagRegistration-LL(NSID-LL("minecraft", ["init"]))
      ],
      decls,
      Body-LL(block')
    )
    with
      {| RegisterDecl, GlobalLookup
      : block' := <transform-block> Block-C([
          AssignStmt-C(
            RefFull-C(IdentFull-C(ns, <concat> [basename, [name]])),
            AssignOperatorEq-C(),
            e
          )
        ])
      ; decl_gen* := <bagof-RegisterDecl; reverse <+ ![]>()
      |}
    ; decls := [decl_gen*]

rules // transform-block :: Block-C -> Block-LL

  is-basic-stmt =
    ?Decl-C(_, _, _, _)
  + ?DiscardStmt-C(_)
  + ?AssignStmt-C(_, _, _)
  + ?DeleteStmt-C(_)

  flow-blocks-from-flow-stmt =
    {| EmitAssign
    : with(rules(EmitAssign:+ _ -> <fail>)) // enforce "empty" dr rhs set
    ; transform-stmt-flow => flow_block
      // collect assigns that were possibly generated by flow conditions
    ; <bagof-EmitAssign; reverse <+ ![]>() => emitted_assigns
    |}
  ; if <?[]> emitted_assigns then
      ![flow_block]
    else
      // if some assigns were emitted, place them in an unconditional flow block before
      ![
        FlowBlock-LL(
          Unconditional-LL(), [],
          BasicBlock-LL(emitted_assigns)
        ),
        flow_block
      ]
    end

  flow-block-from-basic-stmts =
    !FlowBlock-LL(
      Unconditional-LL(), [],
      BasicBlock-LL(<
        map({| EmitAssign
          : with(rules(EmitAssign:+ _ -> <fail>)) // enforce "empty" dr rhs set
          ; transform-stmt-basic
          ; ![<bagof-EmitAssign; reverse <+ ![]>(), [<id>]]
          ; concat
          |})
      ; flatten-list
      >)
    )

  transform-block: Block-C(stmts) -> block_out
    with {| RefType
    : flow_blocks := <rec x({group, sep, tail, blocks, next :
        // try to make a split at the first flow block
        ( split-fetch-keep(not(is-basic-stmt))
        ; ?(group, sep, tail)
          // if the first item matched immediately ...
        ; if <?[]> group then
            // ... then we have found a flow statement,
            // which must be transformed into a single flow block
            blocks := <flow-blocks-from-flow-stmt> sep
          ; next := tail
          else
            // ... otherwise, we have found one or more basic statements,
            // which can be grouped into a single basic block
            blocks := [<flow-block-from-basic-stmts> group]
          ; next := [sep | tail]
          end
        ; <concat> [blocks, <x> next]
        )
        // but if this all fails (due to split-fetch-keep failing),
        // then the entire input must consist of basic statements
     <+ ![<flow-block-from-basic-stmts>]
      })> stmts
    |}
    // NOTE: this simplification step is NOT NECESSARY and could be moved to a dedicated simplification strategy
    with
      // if there ended up only being a single unconditional flow block (WITHOUT modifiers), then just return its content
      if <?[FlowBlock-LL(Unconditional-LL(), [], single_inner_block)]> flow_blocks then
        block_out := single_inner_block
      else
        block_out := FlowGroup-LL(flow_blocks)
      end

rules // transform-ident-full :: IdentFull-C -> NSID-LL

  transform-ident-full: IdentFull-C(ns, names) -> NSID-LL(ns, names)

rules // transform-prop-selector :: Prop-C -> SelectorProp-LL

  // key-value
  transform-prop-selector: PropKv-C(k, v) -> SelectorPropKv-LL(SelectorPropKvEqual-LL(k, <transform-expr(|t)> v))
    with
      t := <selector-value-type> k

  // compare: == or matches
  transform-prop-selector: PropCmp-C(k, <?CmpEqual-C() + ?CmpMatches-C()>, v) -> SelectorPropKv-LL(SelectorPropKvEqual-LL(k, v'))
    with
      t := <selector-value-type> k
    ; v' := <transform-expr(|t)> v
  // compare: !=
  transform-prop-selector: PropCmp-C(k, CmpNotEqual-C(), v) -> SelectorPropKv-LL(SelectorPropKvNotEqual-LL(k, v'))
    with
      t := <selector-value-type> k
    ; v' := <transform-expr(|t)> v
  // compare: >=, <=
  transform-prop-selector: PropCmp-C(k, cmp@<?CmpGte-C() + ?CmpLte-C()>, v) ->
    SelectorPropKv-LL(SelectorPropKvEqual-LL(k, ArgRange-LL(range_low, range_high)))
    with
      t := <selector-value-type> k
    ; v' := <transform-expr(|t)> v
    ; (range_low, range_high) := <
        \CmpGte-C() -> (RangePartSome-LL(v'), RangePartNone-LL())\
      + \CmpLte-C() -> (RangePartNone-LL(), RangePartSome-LL(v'))\
      > cmp
  // compare: >, <
  transform-prop-selector: PropCmp-C(k, cmp@<?CmpGt-C() + ?CmpLt-C()>, v) ->
    SelectorPropKv-LL(SelectorPropKvEqual-LL(k, ArgRange-LL(range_low, range_high)))
    with
      t := <selector-value-type> k
    ; v' := <transform-expr(|t)> v
    ; ident := <newname> "$sel_prop"
    ; rules(RegisterDecl:+ _ -> Decl-LL(
        SLocal-LL(),
        [],
        ident,
        <transform-type> t,
        StorageLocationAuto-LL()
      ))
    ; v'' := ArgVar-LL(ident)
    ; rules(EmitAssign:+ _ -> AssignOp-LL(
        DestVar-LL(ident),
        // add or subtract, depending on given cmp
        <\CmpGt-C() -> OpAdd-LL()\ + \CmpLt-C() -> OpSub-LL()\> cmp,
        [
          v'',
          ArgIntB-LL("1")
        ]
      ))
    ; (range_low, range_high) := <
        \CmpGt-C() -> (RangePartSome-LL(v''), RangePartNone-LL())\
      + \CmpLt-C() -> (RangePartNone-LL(), RangePartSome-LL(v''))\
      > cmp

  // TODO: PropMap-C

rules // transform-expr :: Expr-C -> Arg-LL

  transform-expr(|t): NbtCompound-C(kvs) -> ArgCompound-LL(kvs')
    with
      kvs' := <map(
        \NbtCompoundEntry-C(k, v) -> CompoundEntry-LL(k, <transform-expr(|t')> v)
          with t' := <type-access-compound(|k)> t
        \
      )> kvs
  transform-expr(|t): NbtArray-C(elems) -> ArgArray-LL(<map(transform-expr(|t'))> elems)
    with
      t' := <type-access-list_array> t
  transform-expr(|t): NbtList-C(elems) -> ArgList-LL(<map(transform-expr(|t'))> elems)
    with
      t' := <type-access-list_array> t

  // TODO: insert value coercion if necessary
  transform-expr(|t): String-C(s) -> ArgString-LL(s)
    with
      <type-compat> (t, TypeString-C())
  transform-expr(|t): NumB-C(i) -> ArgIntB-LL(i)
    with
      <type-compat> (t, TypeInt-C())
  transform-expr(|t): NumS-C(i) -> ArgIntS-LL(i)
    with
      <type-compat> (t, TypeInt-C())
  transform-expr(|t): NumI-C(i) -> ArgIntI-LL(i)
    with
      <type-compat> (t, TypeInt-C())
  transform-expr(|t): NumL-C(i) -> ArgIntL-LL(i)
    with
      <type-compat> (t, TypeInt-C())
  transform-expr(|t): NumF-C(f) -> ArgFloatS-LL(f)
    with
      <type-compat> (t, TypeFloat-C())
  transform-expr(|t): NumD-C(f) -> ArgFloatD-LL(f)
    with
      <type-compat> (t, TypeFloat-C())

  transform-expr: Selector-C([root], Props-C(props)) -> ArgSelector-LL(Selector-LL(type, props'))
    with
      type := <
        \"e" -> SelectorE-LL()\
      + \"a" -> SelectorA-LL()\
      + \"p" -> SelectorP-LL()\
      + \"r" -> SelectorR-LL()\
      + \"s" -> SelectorS-LL()\
      > root
    ; props' := <map(transform-prop-selector)> props

  // TODO: res, tag

  /** global-ident :: NSID-LL -> string */
  global-ident =
    GlobalLookup
 <+ ?nsid@NSID-LL(ns, name)
  ; t := <strip-annos; RefType> RefFull-C(IdentFull-C(ns, name))
  ; ident := <newname> "$glob_ref"
  ; (name', name_last) := <split-init-last> name
  ; rules(GlobalLookup: nsid -> ident)
  ; rules(RegisterDecl:+ _ -> Decl-LL(
      SGlobal-LL(),
      [],
      ident,
      <transform-type> t,
      StorageLocationData-LL(NSID-LL(ns, name'), Path-LL([Select-LL(<string-denorm> name_last)]))
    ))
  ; !ident

  transform-expr: RefFull-C(ident_full) -> ArgVar-LL(<transform-ident-full; global-ident> ident_full)
  transform-expr: RefLocal-C(IdentLocal-C(ident)) -> ArgVar-LL(ident)

  transform-expr(|t) =
    (?FindIndex-C(_, _) + ?FindKey-C(_, _))
  ; with(
      unwrap-find => (e', path)
    ; ident := <newname> "$find"
    ; rules(RegisterDecl:+ _ -> Decl-LL(
        SLocal-LL(),
        [],
        ident,
        <transform-type> t,
        StorageLocationAuto-LL()
      ))
    ; rules(EmitAssign:+ _ -> AssignOp-LL(
        DestVar-LL(ident),
        OpFind-LL(),
        [
          e',
          ArgPath-LL(path)
        ]
      ))
    )
  ; !ArgVar-LL(ident)

  transform-expr(|t): Invoke-C(RefFull-C(target), t_ret, arg*) -> ArgVar-LL(ident)
    with
      target' := ArgFunction-LL(<nsid-from-identf> target)
    ; arg'* := <map(\Arg-C(name, t_arg, e) ->
        ArgParam-LL(name, <transform-type> t_arg, <transform-expr(|t_arg)> e)
      \)> arg*
    ; ident := <newname> "$invoke"
    ; t' := <transform-type> t
    ; rules(RegisterDecl:+ _ -> Decl-LL(
        SLocal-LL(),
        [],
        ident,
        t',
        StorageLocationAuto-LL()
      ))
    ; t_ret' := <transform-type> t_ret
    ; rules(EmitAssign:+ _ -> AssignOp-LL(
        DestVar-LL(ident),
        OpInvoke-LL(t_ret'),
        [
          target',
          arg'*
        ]
      ))

  // transform-expr-arith(|Char) :: List(Expr-C) -> Arg-LL
  transform-expr-arith(|t, op): opnds -> ArgVar-LL(ident)
    with
      op' := <
        \'*' -> OpMul-LL()\
      + \'/' -> OpDiv-LL()\
      + \'%' -> OpMod-LL()\
      + \'+' -> OpAdd-LL()\
      + \'-' -> OpSub-LL()\
      > op
    ; opnds' := <map(transform-expr(|t))> opnds
    ; ident := <newname> "$arith"
    ; rules(RegisterDecl:+ _ -> Decl-LL(
        SLocal-LL(),
        [],
        ident,
        <transform-type> t,
        StorageLocationAuto-LL()
      ))
    ; rules(EmitAssign:+ _ -> AssignOp-LL(
        DestVar-LL(ident),
        op',
        opnds'
      ))

  transform-expr(|t) =
    ( ?Mul-C(_, _)
    + ?Div-C(_, _)
    + ?Mod-C(_, _)
    + ?Add-C(_, _)
    + ?Sub-C(_, _)
    )
  ; ?op#([opnd_l, opnd_r])
  ; with(
      op' := <
        \"Mul-C" -> '*'\
      + \"Div-C" -> '/'\
      + \"Mod-C" -> '%'\
      + \"Add-C" -> '+'\
      + \"Sub-C" -> '-'\
      > op
    ; arg' := <transform-expr-arith(|t, op')> [opnd_l, opnd_r]
    )
  ; !arg'

  transform-expr: Cmp-C(lhs, cmp, rhs) ->
    ArgCond-LL(BoolCondCmp-LL(<transform-expr(|TypeBool-C())> lhs, cmp', <transform-expr(|TypeBool-C())> rhs))
    with
      cmp' := <
        \CmpGt-C() -> CmpGt-LL()\
      + \CmpGte-C() -> CmpGte-LL()\
      + \CmpLt-C() -> CmpLt-LL()\
      + \CmpLte-C() -> CmpLte-LL()\
      + \CmpEqual-C() -> CmpEq-LL()\
      > cmp
    // TODO: implement type-contextual comparison

  // TODO: boolean logic
  // TODO: range

  transform-expr(|t): Position-C(kind, PositionCoord-C(x_kind, x), PositionCoord-C(y_kind, y), PositionCoord-C(z_kind, z))
  -> ArgPos-LL(kind', x'_kind, x', y'_kind, y', z'_kind, z')
    with
      // TODO: assert that position kind is compatible with the expected type
      <?TypePos-C(_, t_coord)> t
    with
      kind' := <
        \PositionKindAbs-C() -> PosAbs-LL()\
      + \PositionKindLoc-C() -> PosLoc-LL()\
      + \PositionKindRel-C() -> PosRel-LL()\
      > kind
    ; (x'_kind, y'_kind, z'_kind) := <all(
        \PositionCoordKindAbs-C() -> PosCoordAbs-LL()\
      + \PositionCoordKindDyn-C() -> PosCoordDyn-LL()\
      )> (x_kind, y_kind, z_kind)
    ; (x', y', z') := <all(transform-expr(|t_coord))> (x, y, z)

  transform-expr: Raw-C(parts) -> ArgRaw-LL(parts')
    with
      parts' := <map(
        \RawText-C(str) -> UnsafePartString-LL(str)\
      + \RawFormat-C(format_id, e) -> UnsafePartFormatted-LL(<opt-unwrap(!"none")> format_id, <transform-expr(|TypeUnk-C())> e)\
      )> parts

  transform-expr(|t): Count-C(e) -> ArgVar-LL(ident)
    where
      // check that the expected type is actually int.
      // this should always be the case if generated by gzb2gzbc.
      if <not(eq)> (t, TypeInt-C()) then
        warn(|"Attempt to compute __count in non-Int context")
      end
    with
      e' := <transform-expr(|TypeUnk-C())> e
    ; ident := <newname> "$count"
    ; rules(RegisterDecl:+ _ -> Decl-LL(
        SLocal-LL(),
        [],
        ident,
        <transform-type> t,
        StorageLocationAuto-LL()
      ))
    ; rules(EmitAssign:+ _ -> AssignOp-LL(
        DestVar-LL(ident),
        OpCountElements-LL(),
        [e']
      ))

  transform-expr(|t): NewSingleton-C() -> ArgVar-LL(ident)
    with
      ident := <newname> "$new"
    ; rules(RegisterDecl:+ _ -> Decl-LL(
        SLocal-LL(),
        [],
        ident,
        <transform-type> t,
        StorageLocationAuto-LL()
      ))
    ; rules(EmitAssign:+ _ -> AssignOp-LL(
        DestVar-LL(ident),
        OpNew-LL(),
        []
      ))

  transform-expr(|t): NewDynamic-C(size) -> ArgVar-LL(ident)
    with
      size' := <transform-expr(|TypeInt-C())> size
    ; ident := <newname> "$new"
    ; rules(RegisterDecl:+ _ -> Decl-LL(
        SLocal-LL(),
        [],
        ident,
        <transform-type> t,
        StorageLocationAuto-LL()
      ))
    ; rules(EmitAssign:+ _ -> AssignOp-LL(
        DestVar-LL(ident),
        OpNew-LL(),
        [size']
      ))

  // fallback to transform-expr rules which don't need typing context
  transform-expr(|t) = transform-expr

rules // rvalue/lvalue manipulation

  // arg-lit-int :: Arg-LL -> string
  arg-lit-int: ArgIntB-LL(i) -> i
  arg-lit-int: ArgIntS-LL(i) -> i
  arg-lit-int: ArgIntI-LL(i) -> i
  arg-lit-int: ArgIntL-LL(i) -> i

  unwrap-find--inner: FindIndex-C(e, idx) -> (e, Some(elem))
    with
      idx' := <transform-expr(|TypeInt-C())> idx
    ; if <?ArgVar-LL(var)> idx' then
        elem := IndexDyn-LL(var)
      else
        if lit_int := <arg-lit-int> idx' then
          elem := IndexFix-LL(lit_int)
        else
          debug(!"Unexpected lvalue-find-inner")
        ; fail
        end
      end
  unwrap-find--inner: FindKey-C(e, key) -> (e, Some(Select-LL(key)))
  unwrap-find--inner: e -> (e, None())
  unwrap-find: e -> ((e_out, path), t')
    with
      (e', parts) := <rec x({e', part, part', tail, parts: \e -> (e'', parts)
        with
          (e', part) := <unwrap-find--inner> e
        ; if <?Some(part')> part then
            (e'', tail) := <x> e'
          ; parts := [part' | tail]
          else
            e'' := e'
          ; parts := []
          end
      \})> e
    ; path := Path-LL(<reverse> parts)
    with
      // take RefType, because unwrap-find only supports references
      if not(t := <strip-annos; RefType> e') then
        <err(|"Cannot compute Lvalue on non-reference inner expression")> e'
      ; fail
      end
    ; t' := <type-access-path(|path)> t
    with
      e_out := <transform-expr(|t)> e'

  /** lvalue-mk-varpath :: (Arg-LL, Path-LL) -> AssignDest-LL.DestVarPath-LL */
  // case: preexisting local variable
  lvalue--mk-varpath: (ArgVar-LL(var), path) -> DestVarPath-LL(var, path)
  /** lvalue :: Expr-C -> (AssignDest-LL, Type-C) */
  lvalue =
    unwrap-find
  ; (lvalue--mk-varpath, id)
    // simplfy to DestVar-LL if the path happened to be empty
  ; (try(\DestVarPath-LL(var, Path-LL([])) -> DestVar-LL(var)\), id)

  rvalue-from-lvalue(|_): DestVar-LL(var) -> ArgVar-LL(var)
  rvalue-from-lvalue(|t): DestVarPath-LL(var, path) -> ArgVar-LL(ident)
    with
      ident := <newname> "$rv_from_lv"
    ; rules(RegisterDecl:+ _ -> Decl-LL(
        SLocal-LL(),
        [],
        ident,
        <transform-type> t,
        StorageLocationAuto-LL()
      ))
    ; rules(EmitAssign:+ _ -> AssignOp-LL(
        DestVar-LL(ident),
        OpFind-LL(),
        [
          ArgVar-LL(var),
          ArgPath-LL(path)
        ]
      ))

rules // transform-stmt-basic :: Stmt-C -> Assign-LL

  transform-stmt-basic: Decl-C(kind, name, t, e) ->
    <transform-stmt-basic> AssignStmt-C(refl, AssignOperatorEq-C(), e)
    with
      refl := <strip-annos> RefLocal-C(IdentLocal-C(name))
    ; rules(RefType:+ refl -> t)
    ; if <?DeclKindConst-C()> kind then
        modifiers := [ModConst-LL()]
      else
        modifiers := []
      end
    ; t' := <transform-type> t
    ; rules(RegisterDecl:+ _ -> Decl-LL(
        SLocal-LL(),
        modifiers,
        name, // no need to consider shadowing
        t',
        StorageLocationAuto-LL()
      ))

  transform-stmt-basic: DiscardStmt-C(e) ->
    AssignNew-LL(
      DestDiscard-LL(),
      <transform-expr(|TypeUnk-C())> e
    )

  transform-stmt-basic: AssignStmt-C(dst, AssignOperatorEq-C(), e) ->
    AssignNew-LL(
      dst',
      <transform-expr(|t)> e
    )
    with
      (dst', t) := <lvalue> dst

  transform-stmt-basic: AssignStmt-C(dst, op, e) ->
    AssignOp-LL(
      dst',
      < \AssignOperatorAdd-C() -> OpAdd-LL()\
      + \AssignOperatorSub-C() -> OpSub-LL()\
      + \AssignOperatorMul-C() -> OpMul-LL()\
      + \AssignOperatorDiv-C() -> OpDiv-LL()\
      + \AssignOperatorMod-C() -> OpMod-LL()\
      > op,
      [
        dst_rv,
        <transform-expr(|t)> e
      ]
    )
    with
      (dst', t) := <lvalue> dst
    ; dst_rv := <rvalue-from-lvalue(|t)> dst'

  transform-stmt-basic: DeleteStmt-C(e) ->
    AssignOp-LL(
      <lvalue; Fst> e,
      OpDel-LL(),
      []
    )

rules // transform-stmt-flow :: Stmt-C -> FlowBlock-LL

  transform-stmt-flow: ExecuteStmt-C(fragments*, block) -> res
    with
      fragments'* := <map(tansform-execute-fragment)> fragments*
    ; res := FlowBlock-LL(Execute-LL(fragments'*), [], <transform-block> block)

  transform-stmt-flow: LoopStmt-C(cond, block) -> res
    with
      res := FlowBlock-LL(
        Loop-LL(<transform-expr(|TypeBool-C()); ensure-bool-cond> cond), [],
        <transform-block> block
      )

  /*
  {
    { $if_not_taken0 <- true }
    if cond {
      { $if_not_taken <- false }
      { <b_true> }
    }
    if $if_not_taken0 { <b_false> }
  }
  */
  transform-stmt-flow: IfStmt-C(cond, b_true, b_false) ->
    FlowBlock-LL(Unconditional-LL(), [], FlowGroup-LL([
      // { $if_not_taken0 <- true }
      FlowBlock-LL(Unconditional-LL(), [], BasicBlock-LL([
        AssignNew-LL(DestVar-LL(ident), ArgIntB-LL("1") /*true*/)
      ])),
      // if cond
      FlowBlock-LL(
        If-LL(<transform-expr(|TypeBool-C()); ensure-bool-cond> cond), [],
        FlowGroup-LL([
          // { $if_not_taken <- false }
          FlowBlock-LL(Unconditional-LL(), [], BasicBlock-LL([
            AssignNew-LL(DestVar-LL(ident), ArgIntB-LL("0") /*false*/)
          ])),
          // { <b_true> }
          FlowBlock-LL(Unconditional-LL(), [], <transform-block> b_true)
        ])
      ),
      // if $if_not_taken0
      FlowBlock-LL(
        If-LL(<ensure-bool-cond> ArgVar-LL(ident)), [],
        // { <b_false> }
        <transform-block> b_false
      )
    ]))
    with
      ident := <newname> "$if_not_taken"
    ; rules(RegisterDecl:+ _ -> Decl-LL(
        SLocal-LL(),
        [],
        ident,
        TypeIntB-LL(),
        StorageLocationAuto-LL()
      ))

  // TODO: ReturnExprStmt-C
  transform-stmt-flow: ReturnExprStmt-C(e) ->
    FlowBlock-LL(Unconditional-LL(), [], FlowGroup-LL([]))
  // TODO: ReturnVoidStmt-C
  transform-stmt-flow: ReturnVoidStmt-C() ->
    FlowBlock-LL(Unconditional-LL(), [], FlowGroup-LL([]))

rules // ensure-bool-cond :: Arg-LL -> Arg-LL

  ensure-bool-cond = ?ArgCond-LL(_) // idempotent
  ensure-bool-cond: ArgVar-LL(_) -> ArgCond-LL(BoolCondCmp-LL(<id>, CmpEq-LL(), ArgIntB-LL("1")))
  ensure-bool-cond: ArgIntB-LL(_) -> ArgCond-LL(BoolCondCmp-LL(<id>, CmpEq-LL(), ArgIntB-LL("1")))

  // TODO: support block and entity conditions

rules // selector-value-type :: string -> Type-C

  /** some basic known selector properties with more-or-less correct types (some relaxations) */

  selector-value-type: "dx" -> TypeFloat-C()
  selector-value-type: "dy" -> TypeFloat-C()
  selector-value-type: "dz" -> TypeFloat-C()
  selector-value-type: "limit" -> TypeInt-C()
  selector-value-type: "name" -> TypeString-C()
  selector-value-type: "nbt" -> TypeUnk-C()
  selector-value-type: "sort" -> TypeString-C()
  selector-value-type: "team" -> TypeString-C()
  selector-value-type: "x" -> TypeFloat-C()
  selector-value-type: "x_rotation" -> TypeFloat-C()
  selector-value-type: "y" -> TypeFloat-C()
  selector-value-type: "y_rotation" -> TypeFloat-C()
  selector-value-type: "z" -> TypeFloat-C()
  selector-value-type: "z_rotation" -> TypeFloat-C()

  selector-value-type: "distance" -> TypeFloat-C()
  selector-value-type: "level" -> TypeInt-C()
  selector-value-type: "predicate" -> TypeUnk-C()
  selector-value-type: "gamemode" -> TypeString-C()

  selector-value-type: "tag" -> TypeString-C()
  selector-value-type: "type" -> TypeResourceRegistry-C(IdentFull-C("minecraft", ["entity_type"]))

  selector-value-type: _ -> TypeUnk-C()
