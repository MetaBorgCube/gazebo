module transform

imports

  signatures/gazebo-core/-
  signatures/llmc/-
  signatures/-

  common

  // BUG: transitive from 'common', but included here because otherwise the eclipse editor complains
  str_common

  transform-type

rules // transform-tli(|base) :: Tli-C -> Function-LL

  transform-tli(|base): Function-C(name, Signature-C(params, t_ret), block) ->
    Function-LL(
      <nsid-from-base(|base)> name,
      decls,
      Body-LL(block')
    )
    with
      {| RegisterDecl, GlobalLookup
      : block' := <transform-block> block
      ; decl_gen* := <bagof-RegisterDecl; reverse <+ ![]>()
      |}
    ; decl_sign* := <map({t': \Param-C(kind, name, t) -> Decl-LL(SSign-LL(), mod*, name, t', StorageLocationAuto-LL())
        with
          mod* := <
            \ParamKindConst-C() -> [ModConst-LL()]\
         <+ ![]
          > kind
        ; t' := <transform-type> t
      \})> params
    ; decls := [decl_sign*, decl_gen*]

  transform-tli(|base@[ns|basename]): Decl-C(_, name, _, e) ->
    Function-LL(
      <newname; ![name, <id>]; nsid-from-base(|base)> "_global.init",
      decls,
      Body-LL(block')
    )
    with
      {| RegisterDecl, GlobalLookup
      : block' := <transform-block> Block-C([
          AssignStmt-C(
            RefFull-C(IdentFull-C(ns, <concat> [basename, [name]])),
            AssignOperatorEq-C(),
            e
          )
        ])
      ; decl_gen* := <bagof-RegisterDecl; reverse <+ ![]>()
      |}
    ; decls := [decl_gen*]

rules // transform-block :: Block-C -> Block-LL

  is-basic-stmt =
    ?Decl-C(_, _, _, _)
  + ?DiscardStmt-C(_)
  + ?AssignStmt-C(_, _, _)
  + ?DeleteStmt-C(_)

  flow-blocks-from-flow-stmt =
    {| EmitAssign
    : with(rules(EmitAssign:+ _ -> <fail>)) // enforce "empty" dr rhs set
    ; transform-stmt-flow => flow_block
      // collect assigns that were possibly generated by flow conditions
    ; <bagof-EmitAssign; reverse <+ ![]>() => emitted_assigns
    |}
  ; if <?[]> emitted_assigns then
      ![flow_block]
    else
      // if some assigns were emitted, place them in an unconditional flow block before
      ![
        FlowBlock-LL(
          Unconditional-LL(), [],
          BasicBlock-LL(emitted_assigns)
        ),
        flow_block
      ]
    end

  flow-block-from-basic-stmts =
    !FlowBlock-LL(
      Unconditional-LL(), [],
      BasicBlock-LL(<
        map({| EmitAssign
          : with(rules(EmitAssign:+ _ -> <fail>)) // enforce "empty" dr rhs set
          ; transform-stmt-basic
          ; ![<bagof-EmitAssign; reverse <+ ![]>(), [<id>]]
          ; concat
          |})
      ; flatten-list
      >)
    )

  transform-block: Block-C(stmts) -> block_out
    with
      flow_blocks := <rec x({group, sep, tail, blocks, next :
        // try to make a split at the first flow block
        ( split-fetch-keep(not(is-basic-stmt))
        ; ?(group, sep, tail)
          // if the first item matched immediately ...
        ; if <?[]> group then
            // ... then we have found a flow statement,
            // which must be transformed into a single flow block
            blocks := <flow-blocks-from-flow-stmt> sep
          ; next := tail
          else
            // ... otherwise, we have found one or more basic statements,
            // which can be grouped into a single basic block
            blocks := [<flow-block-from-basic-stmts> group]
          ; next := [sep | tail]
          end
        ; <concat> [blocks, <x> next]
        )
        // but if this all fails (due to split-fetch-keep failing),
        // then the entire input must consist of basic statements
     <+ ![<flow-block-from-basic-stmts>]
      })> stmts
    // NOTE: this simplification step is NOT NECESSARY and could be moved to a dedicated simplification strategy
    with
      // if there ended up only being a single unconditional flow block (WITHOUT modifiers), then just return its content
      if <?[FlowBlock-LL(Unconditional-LL(), [], single_inner_block)]> flow_blocks then
        block_out := single_inner_block
      else
        block_out := FlowGroup-LL(flow_blocks)
      end

rules // transform-ident-full :: IdentFull-C -> NSID-LL

  transform-ident-full: IdentFull-C(ns, names) -> NSID-LL(ns, names)

rules // transform-prop-selector :: Prop-C -> SelectorProp-LL

  // key-value
  transform-prop-selector: PropKv-C(k, v) -> SelectorPropKv-LL(SelectorPropKvEqual-LL(k, <transform-expr> v))

  // compare: == or matches
  transform-prop-selector: PropCmp-C(k, <?CmpEqual-C() + ?CmpMatches-C()>, v) -> SelectorPropKv-LL(SelectorPropKvEqual-LL(k, v'))
    with
      v' := <transform-expr> v
  // compare: !=
  transform-prop-selector: PropCmp-C(k, CmpNotEqual-C(), v) -> SelectorPropKv-LL(SelectorPropKvNotEqual-LL(k, v'))
    with
      v' := <transform-expr>
  // compare: >=, <=
  transform-prop-selector: PropCmp-C(k, cmp@<?CmpGte-C() + ?CmpLte-C()>, v) ->
    SelectorPropKv-LL(SelectorPropKvEqual-LL(k, ArgRange-LL(range_low, range_high)))
    with
      v' := <transform-expr> v
    ; (range_low, range_high) := <
        \CmpGte-C() -> (RangePartSome-LL(v'), RangePartNone-LL())\
      + \CmpLte-C() -> (RangePartNone-LL(), RangePartSome-LL(v'))\
      > cmp
  // compare: >, <
  transform-prop-selector: PropCmp-C(k, cmp@<?CmpGt-C() + ?CmpLt-C()>, v) ->
    SelectorPropKv-LL(SelectorPropKvEqual-LL(k, ArgRange-LL(range_low, range_high)))
    with
      v' := <transform-expr> v
    ; ident := <newname> "$sel_prop"
    ; rules(RegisterDecl:+ _ -> Decl-LL(
        SLocal-LL(),
        [],
        ident,
        TypeUnk-LL(), // TODO: Type-LL
        StorageLocationAuto-LL()
      ))
    ; v'' := ArgVar-LL(ident)
    ; rules(EmitAssign:+ _ -> AssignOp-LL(
        DestVar-LL(ident),
        // add or subtract, depending on given cmp
        <\CmpGt-C() -> OpAdd-LL()\ + \CmpLt-C() -> OpSub-LL()\> cmp,
        [
          v'',
          ArgIntB-LL("1")
        ]
      ))
    ; (range_low, range_high) := <
        \CmpGt-C() -> (RangePartSome-LL(v''), RangePartNone-LL())\
      + \CmpLt-C() -> (RangePartNone-LL(), RangePartSome-LL(v''))\
      > cmp

  // TODO: PropMap-C

rules // transform-expr :: Expr-C -> Arg-LL

  transform-expr: NbtCompound-C(kvs) -> ArgCompound-LL(kvs')
    with
      kvs' := <map(\NbtCompoundEntry-C(k, v) -> CompoundEntry-LL(k, <transform-expr> v)\)> kvs
  transform-expr: NbtArray-C(elems) -> ArgArray-LL(<map(transform-expr)> elems)
  transform-expr: NbtList-C(elems) -> ArgList-LL(<map(transform-expr)> elems)

  transform-expr: String-C(s) -> ArgString-LL(s)
  transform-expr: NumB-C(i) -> ArgIntB-LL(i)
  transform-expr: NumS-C(i) -> ArgIntS-LL(i)
  transform-expr: NumI-C(i) -> ArgIntI-LL(i)
  transform-expr: NumL-C(i) -> ArgIntL-LL(i)
  transform-expr: NumF-C(f) -> ArgFloatS-LL(f)
  transform-expr: NumD-C(f) -> ArgFloatD-LL(f)

  transform-expr: Selector-C([root], Props-C(props)) -> ArgSelector-LL(type, props')
    with
      type := <
        \"e" -> SelectorE-LL()\
      + \"a" -> SelectorA-LL()\
      + \"p" -> SelectorP-LL()\
      + \"r" -> SelectorR-LL()\
      + \"s" -> SelectorS-LL()\
      > root
    ; props' := <map(transform-prop-selector)> props

  // TODO: res, tag

  /** global-ident :: NSID-LL -> string */
  global-ident =
    GlobalLookup
 <+ ?NSID-LL(ns, name)
  ; ident:= <newname> "$glob_ref"
  ; (name', name_last) := <split-init-last> name
  ; rules(GlobalLookup: nsid -> ident)
  ; rules(RegisterDecl:+ _ -> Decl-LL(
      SGlobal-LL(),
      [],
      ident,
      TypeString-LL(), // TODO: Type-LL
      StorageLocationData-LL(NSID-LL(ns, name'), Path-LL([Select-LL(<string-denorm> name_last)]))
    ))
  ; !ident

  transform-expr: RefFull-C(ident_full) -> ArgVar-LL(<transform-ident-full; global-ident> ident_full)
  transform-expr: RefLocal-C(IdentLocal-C(ident)) -> ArgVar-LL(ident)

  transform-expr =
    (?FindIndex-C(_, _) + ?FindKey-C(_, _))
  ; with(
      unwrap-find => (e', path)
    ; ident := <newname> "$find"
    ; rules(RegisterDecl:+ _ -> Decl-LL(
        SLocal-LL(),
        [],
        ident,
        TypeString-LL(), // TODO: Type-LL
        StorageLocationAuto-LL()
      ))
    ; rules(EmitAssign:+ _ -> AssignOp-LL(
        DestVar-LL(ident),
        OpFind-LL(),
        [
          e',
          ArgPath-LL(path)
        ]
      ))
    )
  ; !ArgVar-LL(ident)

  transform-expr: Invoke-C(RefFull-C(target), arg*) -> ArgVar-LL(ident)
    with
      target' := ArgFunction-LL(<nsid-from-identf> target)
    ; arg'* := <map(\Arg-C(name, e) ->
        ArgNamed-LL(name, <transform-expr> e)
      \)> arg*
    ; ident := <newname> "$invoke"
    ; rules(RegisterDecl:+ _ -> Decl-LL(
        SLocal-LL(),
        [],
        ident,
        TypeString-LL(), // TODO: Type-LL
        StorageLocationAuto-LL()
      ))
    ; rules(EmitAssign:+ _ -> AssignOp-LL(
        DestVar-LL(ident),
        OpInvoke-LL(),
        [
          target',
          arg'*
        ]
      ))

  // transform-expr-arith(|Char) :: List(Expr-C) -> Arg-LL
  transform-expr-arith(|op): opnds -> ArgVar-LL(ident)
    with
      op' := <
        \'*' -> OpMul-LL()\
      + \'/' -> OpDiv-LL()\
      + \'%' -> OpMod-LL()\
      + \'+' -> OpAdd-LL()\
      + \'-' -> OpSub-LL()\
      > op
    ; opnds' := <map(transform-expr)> opnds
    ; ident := <newname> "$arith"
    ; rules(RegisterDecl:+ _ -> Decl-LL(
        SLocal-LL(),
        [],
        ident,
        TypeString-LL(), // TODO: Type-LL
        StorageLocationAuto-LL()
      ))
    ; rules(EmitAssign:+ _ -> AssignOp-LL(
        DestVar-LL(ident),
        op',
        opnds'
      ))

  transform-expr =
    ( ?Mul-C(_, _)
    + ?Div-C(_, _)
    + ?Mod-C(_, _)
    + ?Add-C(_, _)
    + ?Sub-C(_, _)
    )
  ; ?op#([opnd_l, opnd_r])
  ; with(
      op' := <
        \"Mul-C" -> '*'\
      + \"Div-C" -> '/'\
      + \"Mod-C" -> '%'\
      + \"Add-C" -> '+'\
      + \"Sub-C" -> '-'\
      > op
    ; arg' := <transform-expr-arith(|op')> [opnd_l, opnd_r]
    )
  ; !arg'

  transform-expr: Cmp-C(lhs, cmp, rhs) ->
    ArgCond-LL(BoolCondCmp-LL(<transform-expr> lhs, cmp', <transform-expr> rhs))
    with
      cmp' := <
        \CmpGt-C() -> CmpGt-LL()\
      + \CmpGte-C() -> CmpGte-LL()\
      + \CmpLt-C() -> CmpLt-LL()\
      + \CmpLte-C() -> CmpLte-LL()\
      + \CmpEqual-C() -> CmpEq-LL()\
      > cmp
    // TODO: implement type-contextual comparison

  // TODO: boolean logic
  // TODO: range
  // TODO: pos
  // TODO: enum ref

  transform-expr: Raw-C(parts) -> ArgRaw-LL(parts')
    with
      parts' := <map(
        \RawText-C(str) -> UnsafePartString-LL(str)\
      + \RawFormat-C(format_id, e) -> UnsafePartFormatted-LL(<opt-unwrap(!"none")> format_id, <transform-expr> e)\
      )> parts

  transform-expr: Count-C(e) -> ArgVar-LL(ident)
    with
      e' := <transform-expr> e
    ; ident := <newname> "$count"
    ; rules(RegisterDecl:+ _ -> Decl-LL(
        SLocal-LL(),
        [],
        ident,
        TypeIntI-LL(),
        StorageLocationAuto-LL()
      ))
    ; rules(EmitAssign:+ _ -> AssignOp-LL(
        DestVar-LL(ident),
        OpCountElements-LL(),
        [e']
      ))

rules // rvalue/lvalue manipulation

  // arg-lit-int :: Arg-LL -> string
  arg-lit-int: ArgIntB-LL(i) -> i
  arg-lit-int: ArgIntS-LL(i) -> i
  arg-lit-int: ArgIntI-LL(i) -> i
  arg-lit-int: ArgIntL-LL(i) -> i

  unwrap-find-inner: FindIndex-C(e, idx) -> (e, Some(elem))
    with
      idx' := <transform-expr> idx
    ; if <?ArgVar-LL(var)> idx' then
        elem := IndexDyn-LL(var)
      else
        if lit_int := <arg-lit-int> idx' then
          elem := IndexFix-LL(lit_int)
        else
          debug(!"Unexpected lvalue-find-inner")
        ; fail
        end
      end
  unwrap-find-inner: FindKey-C(e, key) -> (e, Some(Select-LL(key)))
  unwrap-find-inner: e -> (e, None())
  unwrap-find: e -> (e_out, Path-LL(<reverse> parts))
    with
      (e', parts) := <rec x({e', part, part', tail, parts: \e -> (e'', parts)
        with
          (e', part) := <unwrap-find-inner> e
        ; if <?Some(part')> part then
            (e'', tail) := <x> e'
          ; parts := [part' | tail]
          else
            e'' := e'
          ; parts := []
          end
      \})> e
    with
      e_out := <transform-expr> e'

  /** lvalue-mk-varpath :: (Arg-LL, Path-LL) -> AssignDest-LL.DestVarPath-LL */
  // case: preexisting local variable
  lvalue-mk-varpath: (ArgVar-LL(var), path) -> DestVarPath-LL(var, path)
  /** lvalue :: Expr-C -> AssignDest-LL */
  lvalue =
    unwrap-find
  ; lvalue-mk-varpath
    // simplfy to DestVar-LL if the path happened to be empty
  ; try(\DestVarPath-LL(var, Path-LL([])) -> DestVar-LL(var)\)

  rvalue-from-lvalue: DestVar-LL(var) -> ArgVar-LL(var)
  rvalue-from-lvalue: DestVarPath-LL(var, path) -> ArgVar-LL(ident)
    with
      ident := <newname> "$rv_from_lv"
    ; rules(RegisterDecl:+ _ -> Decl-LL(
        SLocal-LL(),
        [],
        ident,
        TypeString-LL(), // TODO: Type-LL
        StorageLocationAuto-LL()
      ))
    ; rules(EmitAssign:+ _ -> AssignOp-LL(
        DestVar-LL(ident),
        OpFind-LL(),
        [
          ArgVar-LL(var),
          ArgPath-LL(path)
        ]
      ))

rules // transform-stmt-basic :: Stmt-C -> Assign-LL

  transform-stmt-basic: Decl-C(kind, name, t, e) ->
    <transform-stmt-basic> AssignStmt-C(RefLocal-C(IdentLocal-C(name)), AssignOperatorEq-C(), e)
    with
      if <?DeclKindConst-C()> kind then
        modifiers := [ModConst-LL()]
      else
        modifiers := []
      end
    ; t' := <transform-type> t
    ; rules(RegisterDecl:+ _ -> Decl-LL(
        SLocal-LL(),
        modifiers,
        name, // no need to consider shadowing
        t',
        StorageLocationAuto-LL()
      ))

  transform-stmt-basic: DiscardStmt-C(e) ->
    AssignNew-LL(
      DestDiscard-LL(),
      <transform-expr> e
    )

  transform-stmt-basic: AssignStmt-C(dst, AssignOperatorEq-C(), e) ->
    AssignNew-LL(
      <lvalue> dst,
      <transform-expr> e
    )

  transform-stmt-basic: AssignStmt-C(dst, op, e) ->
    AssignOp-LL(
      dst',
      < \AssignOperatorAdd-C() -> OpAdd-LL()\
      + \AssignOperatorSub-C() -> OpSub-LL()\
      + \AssignOperatorMul-C() -> OpMul-LL()\
      + \AssignOperatorDiv-C() -> OpDiv-LL()\
      + \AssignOperatorMod-C() -> OpMod-LL()\
      > op,
      [
        dst_rv,
        <transform-expr> e
      ]
    )
    with
      dst' := <lvalue> dst
    ; dst_rv := <rvalue-from-lvalue> dst'

  transform-stmt-basic: DeleteStmt-C(e) ->
    AssignOp-LL(
      <lvalue> e,
      OpDel-LL(),
      []
    )

rules // transform-stmt-flow :: Stmt-C -> FlowBlock-LL

  // TODO: ExecuteStmt-C

  transform-stmt-flow: LoopStmt-C(cond, block) -> res
    with
      res := FlowBlock-LL(
        Loop-LL(<transform-expr; ensure-bool-cond> cond), [],
        <transform-block> block
      )

  /*
  {
    { $if_not_taken0 <- true }
    if cond {
      { $if_not_taken <- false }
      { <b_true> }
    }
    if $if_not_taken0 { <b_false> }
  }
  */
  transform-stmt-flow: IfStmt-C(cond, b_true, b_false) ->
    FlowBlock-LL(Unconditional-LL(), [], FlowGroup-LL([
      // { $if_not_taken0 <- true }
      FlowBlock-LL(Unconditional-LL(), [], BasicBlock-LL([
        AssignNew-LL(DestVar-LL(ident), ArgIntB-LL("1") /*true*/)
      ])),
      // if cond
      FlowBlock-LL(
        If-LL(<transform-expr; ensure-bool-cond> cond), [],
        FlowGroup-LL([
          // { $if_not_taken <- false }
          FlowBlock-LL(Unconditional-LL(), [], BasicBlock-LL([
            AssignNew-LL(DestVar-LL(ident), ArgIntB-LL("0") /*false*/)
          ])),
          // { <b_true> }
          FlowBlock-LL(Unconditional-LL(), [], <transform-block> b_true)
        ])
      ),
      // if $if_not_taken0
      FlowBlock-LL(
        If-LL(<ensure-bool-cond> ArgVar-LL(ident)), [],
        // { <b_false> }
        <transform-block> b_false
      )
    ]))
    with
      ident := <newname> "$if_not_taken"
    ; rules(RegisterDecl:+ _ -> Decl-LL(
        SLocal-LL(),
        [],
        ident,
        TypeIntB-LL(),
        StorageLocationAuto-LL()
      ))

  // TODO: ReturnExprStmt-C
  transform-stmt-flow: ReturnExprStmt-C(e) ->
    FlowBlock-LL(Unconditional-LL(), [], FlowGroup-LL([]))
  // TODO: ReturnVoidStmt-C
  transform-stmt-flow: ReturnVoidStmt-C() ->
    FlowBlock-LL(Unconditional-LL(), [], FlowGroup-LL([]))

rules // ensure-bool-cond :: Arg-LL -> Arg-LL

  ensure-bool-cond = ?ArgCond-LL(_) // idempotent
  ensure-bool-cond: ArgVar-LL(_) -> ArgCond-LL(BoolCondCmp-LL(<id>, CmpEq-LL(), ArgIntB-LL("1")))
  ensure-bool-cond: ArgIntB-LL(_) -> ArgCond-LL(BoolCondCmp-LL(<id>, CmpEq-LL(), ArgIntB-LL("1")))

  // TODO: support block and entity conditions
