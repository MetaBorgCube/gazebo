module statics/common

imports

    signatures/gazebo-sig
    statics/types

signature

    name-resolution

        labels
            P // parent
            M // module boundary
            I // star import (use)
            A // alias-of (for selectors)
            B // base (interfaces)
            O // origin (interfaces)

    sorts

        PROP
        MEMB_KIND

    constructors

        PROP_OVERRIDABLE : TYPE -> PROP
        PROP_FINAL : TYPE -> PROP

        MEMB_MODVARFN : MEMB_KIND
        MEMB_TYPE : MEMB_KIND
        MEMB_ENUMKEY : MEMB_KIND

    relations

        mod : NSID -> TYPE
        currmod : -> (NSID * TYPE)
        memb : (string * MEMB_KIND) -> TYPE
        field : string -> TYPE
        registry : NSID -> scope
        registration : NSID -> scope
        regmeta : string -> scope
        bs : string -> TYPE
        alias : string -> scope
        prop : string -> PROP
        enumkey : -> string
        tinj : -> TYPE

rules

    withTypeInject : scope * TYPE -> scope

    withTypeInject(s, T) = s_tinj :-
        new s_tinj, s_tinj -P-> s,
        !tinj[T] in s_tinj.

rules

    currentMod : scope -> (NSID * scope)

    // TODO: this could maybe also be implemented without the explicit presence of the currmod relation
    currentMod(s) = (name, s_mod) :- {p p' T}
        query currmod
            filter P* and true
            min $ < P and false
            in s |-> p,
        p == [(p', (name, T))] | error $[no single mod, instead: [p]],
        T == MOD(s_mod).

rules

    stringListContains : list(string) * string
    stringListContains([], _) :- false.
    stringListContains([x], s) :- x == s.
    stringListContains([x|xs], s) :- x == s.

    stringListConcat : list(string) * list(string) -> list(string)
    stringListConcat([], r) = r.
    stringListConcat([x|xs], r) = [x | stringListConcat(xs, r)].

    stringListInit : list(string) -> list(string)
    stringListInit([]) = [].
    stringListInit([x]) = [].
    stringListInit([x | xs@[y|ys]]) = [x | stringListInit(xs)].

    stringListLast : list(string) -> string
    stringListLast([]) = "?" :- false | error $[cannot get last element from empty list].
    stringListLast([x]) = x.
    stringListLast([x|xs]) = stringListLast(xs).

rules

    nsid : string * list(string) -> NSID

    nsid(namespace, names) = NSID(namespace, NSIDName(names)).

    nsidName : NSID -> NSIDName
    nsidName(NSID(_, name)) = name.
    nsidName(NSIDShort(name)) = name.
    nsidName(NSIDRel(name)) = name.

    nsidNameConcat : NSIDName * NSIDName -> NSIDName

    nsidNameConcat(NSIDName(a), NSIDName(b)) = NSIDName(stringListConcat(a, b)).

    nsidNameStripLast : NSIDName -> NSIDName

    nsidNameStripLast(NSIDName(name)) = NSIDName(stringListInit(name)).

rules

    /** rel * base -> abs */
    absolute : NSID * NSID -> NSID

    /** good: already absolute */
    absolute(rel@NSID(_, _), _) = rel.

    /** good: relative to namespace of base */
    absolute(NSIDShort(rel), NSID(base_ns, _)) = NSID(base_ns, rel).

    /** good: sub-name relative to base */
    absolute(rel@NSIDRel(name), NSID(base_ns, base_name)) = NSID(base_ns, nsidNameConcat(nsidNameStripLast(base_name), name)).

    /** bad: misc */
    absolute(rel@NSIDShort(name), base) = rel :-
        false | error $[cannot compute absolute NSID of :[name] relative to [base]].

    /** bad: misc */
    absolute(rel@NSIDRel(name), base) = rel :-
        false | error $[cannot compute absolute NSID of [name] relative to [base]].
