module statics/expr/tag-resource

imports

    statics/common
    statics/bind/registry
    statics/bind/registration

rules // tag

    typeOfTag : scope * Tag -> TYPE

    typeOfTag(s, Tag(_)) = TAG().

rules // resource

    typeOfResource : scope * Resource -> TYPE

    typeOfResource(s, ResourceBare(ident)) =
        typeOfResource(s, ResourceFull(ident, Props([]), NBTCompound([]))).

    typeOfResource(s, ResourceProps(ident, props)) =
        typeOfResource(s, ResourceFull(ident, props, NBTCompound([]))).

    typeOfResource(s, ResourceNBT(ident, payl)) =
        typeOfResource(s, ResourceFull(ident, Props([]), payl)).

    typeOfResource(s, ResourceFull(ident, props, payl)) = T :- {id_registry s_registry id_registration s_registration}
        inferRegistry(s, ident) == ((id_registry, s_registry), (id_registration, s_registration)),
        T == RESOURCE(id_registry),
        try { false } | note $[todo: check props and payl]@ident.

rules

    inferRegistry : scope * TRIdent -> ((NSID * scope) * (NSID * scope))

    inferRegistry(s, TRIdentExplicit(id_registry, id_registration)) = ((id_registry_full, s_registry), (id_registration_full, s_registration)) :-
        resolveRegistryRel(s, id_registry) == (id_registry_full, s_registry)
        | error $[registry not found]@id_registry,
        @id_registry.ref := id_registry_full,
        resolveRegistration(s_registry, id_registration) == (id_registration_full, s_registration)
        | error $[registration not found in registry]@id_registration,
        @id_registration.ref := id_registration_full.

    inferRegistry(s, TRIdentAnonymous(id_registration)) =
        res@resolveRegistryAndRegistrationFromAllRegistries(s, allRegistries(s), id_registration) :- {registration}
        res == ((_, _), (registration, _)),
        @id_registration.ref := registration.
