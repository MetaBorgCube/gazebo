module statics

// see README.md for details on how to switch to multi-file analysis

imports

    statics/common
    statics/use
    statics/tli
    statics/bind/alias
    statics/bind/mod
    statics/bind/memb
    statics/bind/prop

rules

    /** declare the selectors @e, @a, @p, @r and @s as aliases */
    populateDefaultSelectors : scope
    populateDefaultSelectors(s_root) :- {s_sel_e s_sel_a s_sel_p s_sel_r s_sel_s}
        // @e: the base selector of all selectors
        new s_sel_e,
        declareAlias(s_root, "e", s_sel_e),
        // TODO: mark registration explicitly as $gzb:base_entity
        // [type==$<minecraft:entity_type>gzb:base_entity]
        declareProp(s_sel_e, "type", PROP_OVERRIDABLE(RESOURCE(NSIDiFull("minecraft", ["entity_type"])))),

        // @a: all players
        new s_sel_a, s_sel_a -A-> s_sel_e,
        declareAlias(s_root, "a", s_sel_a),
        // TODO: mark value as $minecraft:player
        // [type==$<minecraft:entity_type>minecraft:player]
        declareProp(s_sel_a, "type", PROP_FINAL(RESOURCE(NSIDiFull("minecraft", ["entity_type"])))),

        // @p: nearest players
        new s_sel_p, s_sel_p -A-> s_sel_a,
        declareAlias(s_root, "p", s_sel_p),
        // [sort="nearest",limit=1]
        declareProp(s_sel_p, "sort", PROP_FINAL(STRING())),
        declareProp(s_sel_p, "limit", PROP_FINAL(INT())),

        // @r: random players
        new s_sel_r, s_sel_r -A-> s_sel_a,
        // [sort="random",limit=1]
        declareAlias(s_root, "r", s_sel_r),
        declareProp(s_sel_r, "sort", PROP_FINAL(STRING())),
        declareProp(s_sel_r, "limit", PROP_FINAL(INT())),

        // @s: sender
        new s_sel_s, s_sel_s -A-> s_sel_e,
        declareAlias(s_root, "s", s_sel_s),
        // TODO: implement proper semantics
        // [limit=1]
        declareProp(s_sel_s, "limit", PROP_FINAL(INT())).

rules

    /** root * mod nsid * uses * tlis */
    ok : scope * NSIDi * list(Use) * list(Tli)

    ok(s_root, nsid, uses, tlis) :- {s_mod Tmod}
        new s_mod, s_mod -M-> s_root,
        Tmod == MOD(s_mod),
        declareMod(s_root, nsid, Tmod),
        !currmod[(nsid, Tmod)] in s_mod,

        usesOk(s_mod, uses),
        tlisOk(s_root, s_mod, tlis).

rules

    startOk : scope * Start

    startOk(s_root, Start(u, t)) :-
        try { false } | warning $[no module indentification],
        ok(s_root, NSIDiFull("myns", ["myname"]), u, t).

    startOk(s_root, StartModule(nsid, u, t)) :-
        ok(s_root, nsidi(nsid), u, t).

    startOk(s_root, StartInject(nsid, u, t)) :-
        ok(s_root, nsid, u, t).

rules

    init : scope

    init(s_root) :- {s_mod_mc_world s_mod_mc_text}
        populateDefaultSelectors(s_root),
        // TODO: declare global gamemode enum???

        new s_mod_mc_world, s_mod_mc_world -M-> s_root,
        declareMod(s_root, NSIDiFull("minecraft", ["world"]), MOD(s_mod_mc_world)),
        declareMemb(s_mod_mc_world, "setblock",
            MEMB_MODVARFN(),
            FUNC([
                // TODO: allow any pos
                ("pos", POS(POS_ABS(), INT())),
                ("block", RESOURCE(NSIDiFull("minecraft", ["block"])))
            ], VOID())
        ),

        new s_mod_mc_text, s_mod_mc_text -M-> s_root,
        declareMod(s_root, NSIDiFull("minecraft", ["text"]), MOD(s_mod_mc_text)),
        declareMemb(s_mod_mc_text, "say",
            MEMB_MODVARFN(),
            FUNC([
                ("text", STRING())
            ], VOID())
        ).

rules // single-file entry point

    programOk : Start

    programOk(start) :- {s_root}
        new s_root,
        init(s_root),
        startOk(s_root, start).

rules // multi-file entry point

    projectOk : scope

    projectOk(s_root) :-
        new s_root,
        init(s_root).

    fileOk : scope * Start

    fileOk(s_root, start) :-
        startOk(s_root, start).
