module statics/bind/mod

imports

    statics/common

rules

    declareMod : scope * NSID * TYPE

    declareMod(s, name, T) :-
        !mod[name, T] in s.

rules

    queryMod : scope * NSID -> list((path * (NSID * TYPE)))

    queryMod(s, name) = p :-
        query mod
            filter P* M and { x :- x == name }
            min $ < P, $ < M and false
            in s |-> p.

rules

    resolveMod : scope * NSID -> TYPE

    resolveMod(s, name) = T :- {p p'}
        queryMod(s, name) == p,
        p == [(p', (_, T))] | error $[module [name] not resolved],
        T == MOD(_).

rules

    /**
     * Resolve a module relative to the current module.
     * If the given NSID is absolute, this function does not add any functionality.
     * Any scope which has some path to the root scope suffices.
     * A resolve is also attempted to the implicit namespaces.
     */
    resolveModRel : scope * NSID -> TYPE

    resolveModRel(s, nsid) = T :- {curr abs}
        // relativize the specified NSID to the current module
        currentMod(s) == (curr, _),
        abs == absolute(nsid, curr),

        // TODO: attempt to import from the "minecraft" or "gzb" namespaces (the "implicit" namespaces)

        // resolve
        resolveMod(s, abs) == T@MOD(_).

rules

    currentMod : scope -> (NSID * scope)

    // TODO: this could maybe also be implemented without the explicit presence of the currmod relation
    currentMod(s) = (name, s_mod) :- {p p' T}
        query currmod
            filter P* and true
            min $ < P and false
            in s |-> p,
        p == [(p', (name, T))] | error $[no single mod, instead: [p]],
        T == MOD(s_mod).
