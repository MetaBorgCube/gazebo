module statics/bind/mod

imports

    statics/common

rules

    declareMod : scope * NSID * TYPE

    declareMod(s, name, T) :-
        !mod[name, T] in s.

rules

    queryMod : scope * NSID -> list((path * (NSID * TYPE)))

    queryMod(s, name) = p :-
        query mod
            filter P* M and { x :- x == name }
            min $ < P, $ < M and false
            in s |-> p.

rules

    concatQueryModRes : list((path * (NSID * TYPE))) * list((path * (NSID * TYPE))) -> list((path * (NSID * TYPE)))
    concatQueryModRes([], r) = r.
    concatQueryModRes([x|xs], r) = [x | concatQueryModRes(xs, r)].

    flattenQueryModRes : list(list((path * (NSID * TYPE)))) -> list((path * (NSID * TYPE)))
    flattenQueryModRes([]) = [].
    flattenQueryModRes([x]) = x.
    flattenQueryModRes([x|xs]) = concatQueryModRes(x, flattenQueryModRes(xs)).

rules

    resolveMod : scope * NSID -> TYPE

    resolveMod(s, name) = T :- {p p'}
        queryMod(s, name) == p,
        p == [(p', (_, T))] | error $[module [name] not resolved],
        T == MOD(_).

rules

    /**
     * Resolve a module relative to the current module.
     * If the given NSID is absolute, this function does not add any functionality.
     * Any scope which has some path to the root scope suffices.
     * A resolve is also attempted to the implicit namespaces.
     */
    resolveModRel : scope * NSID -> TYPE

    resolveModRel(s, nsid) = T :- {curr abs imMc imGzb qcomb p'}
        // relativize the specified NSID to the current module
        currentMod(s) == (curr, _),
        abs == absolute(nsid, curr),

        // prep implicit
        imMc == absolute(nsid, nsid("minecraft", [])),
        imGzb == absolute(nsid, nsid("gzb", [])),

        // resolve in order
        qcomb == flattenQueryModRes([
            queryMod(s, abs),
            queryMod(s, imMc),
            queryMod(s, imGzb)
        ]),

        // take head if exists, so respecting search order
        qcomb == [(p', (_, T@MOD(_))) | _].

rules

    currentMod : scope -> (NSID * scope)

    // TODO: this could maybe also be implemented without the explicit presence of the currmod relation
    currentMod(s) = (name, s_mod) :- {p p' T}
        query currmod
            filter P* and true
            min $ < P and false
            in s |-> p,
        p == [(p', (name, T))] | error $[no single mod, instead: [p]],
        T == MOD(s_mod).
