module statics/types

imports

    signatures/NSID-sig
    signatures/Type-sig
    statics/common
    statics/bind/memb

signature

    sorts TYPE

    constructors

        // Primitives
        STRING : TYPE
        BOOL : TYPE
        INT : TYPE
        FLOAT : TYPE
        ENUM : scope -> TYPE

        // Basic constructs
        POS : POS_KIND * TYPE -> TYPE
        RANGE : TYPE -> TYPE

        // Specific types
        SELECTOR : scope -> TYPE
        TAG : TYPE
        /** registry */
        RESOURCE : NSID -> TYPE
        ITER : TYPE -> TYPE
        VOID : TYPE

        // NBT-related exclusive types
        COMPOUND : scope -> TYPE
        LIST : TYPE -> TYPE
        ARRAY : TYPE -> TYPE

        // Modules
        MOD : scope -> TYPE

        // Lambda
        LAMBDA : TYPE

        // Members (constants, variables, functions)
        CONST : TYPE
        VAR : TYPE
        FUNC : list((ID * TYPE)) * TYPE -> TYPE

        // Misc
        UNK : TYPE
        ENUMKEY : TYPE

    sorts POS_KIND

    constructors

        /** absolute */
        POS_ABS : POS_KIND
        /** relative ("tilde notation") */
        POS_REL : POS_KIND
        /** local ("caret notation") */
        POS_LOC : POS_KIND

rules

    typeOfType : scope * Type -> TYPE

    typeOfType(_, TypeString()) = STRING().
    typeOfType(_, TypeBool()) = BOOL().
    typeOfType(_, TypeInt()) = INT().
    typeOfType(_, TypeFloat()) = FLOAT().

    typeOfType(_, TypeTag()) = TAG().

    // TODO: type of resource registry, interface, distinguish between different array/list fixed types

    typeOfType(s, TypeRef(nsid)) = T :-
        T == resolveMembRef(s, nsid, MEMB_TYPE()).

    typeOfType(s, TypeArrayDynamic(t)) = ARRAY(T) :-
        T == typeOfType(s, t).
    typeOfType(s, TypeArrayFixedAnonymous(t, size)) = ARRAY(T) :-
        T == typeOfType(s, t).
    typeOfType(s, TypeArrayFixedNamed(t, names)) = ARRAY(T) :-
        T == typeOfType(s, t).

    typeOfType(s, TypeListDynamic(t)) = LIST(T) :-
        T == typeOfType(s, t).
    typeOfType(s, TypeListFixedAnonymous(t, size)) = LIST(T) :-
        T == typeOfType(s, t).
    typeOfType(s, TypeListFixedNamed(t, names)) = LIST(T) :-
        T == typeOfType(s, t).

    typeOfType(s, TypeEnum(keys)) = ENUM(s_enum) :-
        new s_enum, s_enum -P-> s,
        declareEnumKeys(s_enum, keys).

    typeOfType(_, _) = UNK() :-
        try { false } | note $[todo: other types].

rules

    declareEnumKeys maps declareEnumKey(*, list(*))
    declareEnumKey : scope * string
    declareEnumKey(s, key) :-
        declareMemb(s, key, MEMB_ENUMKEY(), ENUMKEY()).

rules

    /** check if first type is a subtype of the second type */
    // TODO: check if all possibilities are defined
    subtype : TYPE * TYPE

    subtype(INT(), FLOAT()).

    // TODO: ensure POS kinds are legal
    subtype(POS(ka, Ta), POS(kb, Tb)) :- subtype(Ta, Tb).
    subtype(RANGE(a), RANGE(b)) :- subtype(a, b).

    subtype(ITER(a), ITER(b)) :- subtype(a, b).

    //COMPOUND
    subtype(LIST(a), LIST(b)) :- subtype(a, b).
    subtype(ARRAY(a), ARRAY(b)) :- subtype(a, b).

    subtype(_, UNK()).
    //LAMBDA

    subtype(a, b) :- a == b.

rules

    /** derive least upper bound */
    // TODO: check if all possibilities are defined
    lub : TYPE * TYPE -> TYPE

    lub(FLOAT(), INT()) = FLOAT().
    lub(INT(), FLOAT()) = FLOAT().

    //lub(POS(a), POS(b)) :- lub(a, b).
    lub(RANGE(a), RANGE(b)) = RANGE(lub(a, b)).

    lub(ITER(a), ITER(b)) = ITER(lub(a, b)).

    //COMPOUND: intersection
    lub(LIST(a), LIST(b)) = LIST(lub(a, b)).
    lub(ARRAY(a), ARRAY(b)) = ARRAY(lub(a, b)).

    lub(a, UNK()) = a.
    lub(UNK(), b) = b.

    lub(a, b) = a :-
        a == b | error $[no type commonality].

rules

    typeBoolish : TYPE

    typeBoolish(BOOL()).
    typeBoolish(SELECTOR(_)).
    typeBoolish(POS(_, INT())).
    typeBoolish(POS(_, FLOAT())).
    typeBoolish(_) :- false.

rules

    /** resolves to UNK if type is not iterable */
    typeUnwrapIter : TYPE -> TYPE
    typeUnwrapIter(ITER(T)) = T.
    typeUnwrapIter(LIST(T)) = T.
    typeUnwrapIter(ARRAY(T)) = T.
    typeUnwrapIter(T) = UNK().

rules

    destructType : TYPE -> list(TYPE)
    destructType(POS(POS_ABS(), T)) = [T, T, T].
    destructType(t) = [] :- false | error $[cannot destruct type [t]].
