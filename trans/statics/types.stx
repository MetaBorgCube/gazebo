module statics/types

imports

    signatures/NSID-sig
    signatures/Type-sig
    statics/common
    statics/bind/field
    statics/bind/memb

signature

    sorts TYPE

    constructors

        // Primitives
        STRING : TYPE
        BOOL : TYPE
        INT : TYPE
        FLOAT : TYPE
        ENUM : scope -> TYPE

        // Basic constructs
        POS : POS_KIND * TYPE -> TYPE
        RANGE : TYPE -> TYPE

        // Specific types
        SELECTOR : scope -> TYPE
        TAG : TYPE
        /** registry */
        RESOURCE : NSID -> TYPE
        ITER : TYPE -> TYPE
        VOID : TYPE

        // NBT-related exclusive types
        COMPOUND : scope -> TYPE
        LIST : TYPE -> TYPE
        ARRAY : TYPE -> TYPE

        // Modules
        MOD : scope -> TYPE

        // Lambda
        LAMBDA : TYPE

        // Members (constants, variables, functions)
        CONST : TYPE
        VAR : TYPE
        FUNC : list((ID * TYPE)) * TYPE -> TYPE

        // Misc
        UNK : TYPE
        ENUMKEY : TYPE

    sorts POS_KIND

    constructors

        /** absolute */
        POS_ABS : POS_KIND
        /** relative ("tilde notation") */
        POS_REL : POS_KIND
        /** local ("caret notation") */
        POS_LOC : POS_KIND

rules

    typeOfType : scope * Type -> TYPE

    typeOfType(_, TypeString()) = STRING().
    typeOfType(_, TypeBool()) = BOOL().
    typeOfType(_, TypeInt()) = INT().
    typeOfType(_, TypeFloat()) = FLOAT().

    typeOfType(_, TypeTag()) = TAG().

    // TODO: type of resource registry, interface, distinguish between different array/list fixed types

    typeOfType(s, TypeRef(nsid)) = T :-
        T == resolveMembRef(s, nsid, MEMB_TYPE()).

    typeOfType(s, TypeArrayDynamic(t)) = ARRAY(T) :-
        T == typeOfType(s, t).
    typeOfType(s, TypeArrayFixedAnonymous(t, size)) = ARRAY(T) :-
        T == typeOfType(s, t).
    typeOfType(s, TypeArrayFixedNamed(t, names)) = ARRAY(T) :-
        T == typeOfType(s, t).

    typeOfType(s, TypeListDynamic(t)) = LIST(T) :-
        T == typeOfType(s, t).
    typeOfType(s, TypeListFixedAnonymous(t, size)) = LIST(T) :-
        T == typeOfType(s, t).
    typeOfType(s, TypeListFixedNamed(t, names)) = LIST(T) :-
        T == typeOfType(s, t).

    typeOfType(s, TypeEnum(keys)) = ENUM(s_enum) :-
        new s_enum,
        declareEnumKeys(s_enum, keys).

    typeOfType(s, TypeInterface(membs)) = COMPOUND(s_interf) :-
        new s_interf,
        declareInterfaceMembers(s, s_interf, membs).
    typeOfType(s, TypeInterfaceCompose(bases, membs)) = COMPOUND(s_interf) :- {ss_bases}
        ss_bases == interfaceBaseScopes(s, bases),
        new s_interf,
        declareInterfaceMembers(s, s_interf, membs),
        linkBaseScopes(s_interf, ss_bases),
        interfaceShadowOk(s_interf).

    typeOfType(_, _) = UNK() :-
        try { false } | note $[todo: other types].

rules // type enum

    declareEnumKeys maps declareEnumKey(*, list(*))
    declareEnumKey : scope * string
    declareEnumKey(s, key) :-
        declareMemb(s, key, MEMB_ENUMKEY(), ENUMKEY()).

rules // type interface

    interfaceBaseScopes maps interfaceBaseScope(*, list(*)) = list(*)
    interfaceBaseScope : scope * Type -> scope
    interfaceBaseScope(s, t) = s_comp :- {T}
        T == typeOfType(s, t),
        s_comp == interfaceBaseScope_matchCompound(T) | error $[cannot compose with a non-interface type]@t.

    interfaceBaseScope_matchCompound : TYPE -> scope
    interfaceBaseScope_matchCompound(COMPOUND(s_comp)) = s_comp.
    interfaceBaseScope_matchCompound(_) = new :- false.

    linkBaseScopes maps linkBaseScope(*, list(*))
    linkBaseScope : scope * scope
    linkBaseScope(s_curr, s_base) :- s_curr -B-> s_base.

    declareInterfaceMembers maps declareInterfaceMember(*, *, list(*))
    declareInterfaceMember : scope * scope * InterfaceMember
    declareInterfaceMember(s, s_interf, InterfaceMember(name, t)) :- {T}
        T == typeOfType(s, t),
        declareField(s_interf, name, T).

    interfaceShadowOk : scope
    // TODO: implement shadow OK check
    interfaceShadowOk(s).

rules

    /** check if first type is a subtype of the second type */
    // TODO: check if all possibilities are defined
    subtype : TYPE * TYPE

    subtype(INT(), FLOAT()).

    // TODO: ensure POS kinds are legal
    subtype(POS(ka, Ta), POS(kb, Tb)) :- subtype(Ta, Tb).
    subtype(RANGE(a), RANGE(b)) :- subtype(a, b).

    subtype(ITER(a), ITER(b)) :- subtype(a, b).

    subtype(COMPOUND(s_comp_a), COMPOUND(s_comp_b)) :- subtypeCompound(s_comp_a, s_comp_b).
    subtype(LIST(a), LIST(b)) :- subtype(a, b).
    subtype(ARRAY(a), ARRAY(b)) :- subtype(a, b).

    subtype(_, UNK()).
    //LAMBDA

    subtype(a, b) :- a == b.

rules

    /** check if the first compound scope is a structural subtype of the second compound scope */
    subtypeCompound : scope * scope

    subtypeCompound(s_comp_a, s_comp_b) :- {allmembs_b}
        // all members of 'b' must be present in 'a' with the 'a' items being a subtype of the corresponding 'b' item,
        // but 'a' may have more members
        allmembs_b == queryAllFields(s_comp_b),
        subtypeCompound_membersOk(s_comp_a, allmembs_b).

    subtypeCompound_membersOk maps subtypeCompound_memberOk(*, list(*))
    subtypeCompound_memberOk : scope * (path * (string * TYPE))
    subtypeCompound_memberOk(s_comp_a, memb_b@(_, (name, Tb))) :- {Ta}
        (_, Ta) == resolveField(s_comp_a, name),
        subtype(Ta, Tb).

rules

    /** derive least upper bound */
    // TODO: check if all possibilities are defined
    lub : TYPE * TYPE -> TYPE

    lub(FLOAT(), INT()) = FLOAT().
    lub(INT(), FLOAT()) = FLOAT().

    //lub(POS(a), POS(b)) :- lub(a, b).
    lub(RANGE(a), RANGE(b)) = RANGE(lub(a, b)).

    lub(ITER(a), ITER(b)) = ITER(lub(a, b)).

    lub(COMPOUND(s_comp_a), COMPOUND(s_comp_b)) = COMPOUND(intersectCompound(s_comp_a, s_comp_b)).
    lub(LIST(a), LIST(b)) = LIST(lub(a, b)).
    lub(ARRAY(a), ARRAY(b)) = ARRAY(lub(a, b)).

    lub(a, UNK()) = a.
    lub(UNK(), b) = b.

    lub(a, b) = a :-
        a == b | error $[no type commonality].

rules

    intersectCompound : scope * scope -> scope

    // TODO: this is a placeholder implementation
    intersectCompound(s_comp_a, s_comp_b) = s_int :-
        new s_int, s_int -B-> s_comp_a, s_int -B-> s_comp_b.

rules

    typeBoolish : TYPE

    typeBoolish(BOOL()).
    typeBoolish(SELECTOR(_)).
    typeBoolish(POS(_, INT())).
    typeBoolish(POS(_, FLOAT())).
    typeBoolish(_) :- false.

rules

    /** resolves to UNK if type is not iterable */
    typeUnwrapIter : TYPE -> TYPE
    typeUnwrapIter(ITER(T)) = T.
    typeUnwrapIter(LIST(T)) = T.
    typeUnwrapIter(ARRAY(T)) = T.
    typeUnwrapIter(T) = UNK().

rules

    destructType : TYPE -> list(TYPE)
    destructType(POS(POS_ABS(), T)) = [T, T, T].
    destructType(t) = [] :- false | error $[cannot destruct type [t]].
