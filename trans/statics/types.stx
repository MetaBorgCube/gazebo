module statics/types

imports

    signatures/NSID-sig
    signatures/Type-sig
    statics/common
    statics/bind/field
    statics/bind/memb
    statics/type/bounds
    statics/type/enum
    statics/type/interface

signature

    sorts TYPE

    constructors

        // Primitives
        STRING : TYPE
        BOOL : TYPE
        INT : TYPE
        FLOAT : TYPE
        ENUM : scope -> TYPE

        // Basic constructs
        POS : POS_KIND * TYPE -> TYPE
        RANGE : TYPE -> TYPE

        // Specific types
        SELECTOR : scope -> TYPE
        TAG : TYPE
        /** registry */
        RESOURCE : NSID -> TYPE
        ITER : TYPE -> TYPE
        VOID : TYPE

        // NBT-related exclusive types
        COMPOUND : scope -> TYPE
        LIST : TYPE -> TYPE
        ARRAY : TYPE -> TYPE

        // Modules
        MOD : scope -> TYPE

        // Lambda
        LAMBDA : TYPE

        // Members (constants, variables, functions)
        CONST : TYPE
        VAR : TYPE
        FUNC : list((ID * TYPE)) * TYPE -> TYPE

        // Misc
        /** univeral top type, anything is a subtype of UNK */
        UNK : TYPE
        /** universal bottom type, nothing is a subtype of BOTTOM */
        BOTTOM : TYPE
        ENUMKEY : TYPE

    sorts POS_KIND

    constructors

        /** absolute */
        POS_ABS : POS_KIND
        /** relative ("tilde notation") */
        POS_REL : POS_KIND
        /** local ("caret notation") */
        POS_LOC : POS_KIND

rules

    typeOfType : scope * Type -> TYPE

    typeOfType(_, TypeString()) = STRING().
    typeOfType(_, TypeBool()) = BOOL().
    typeOfType(_, TypeInt()) = INT().
    typeOfType(_, TypeFloat()) = FLOAT().

    typeOfType(_, TypeTag()) = TAG().

    // TODO: type of resource registry, distinguish between different array/list fixed types

    typeOfType(s, TypeRef(nsid)) = T :-
        T == resolveMembRef(s, nsid, MEMB_TYPE()).

    typeOfType(s, TypeArrayDynamic(t)) = ARRAY(T) :-
        T == typeOfType(s, t).
    typeOfType(s, TypeArrayFixedAnonymous(t, size)) = ARRAY(T) :-
        T == typeOfType(s, t).
    typeOfType(s, TypeArrayFixedNamed(t, names)) = ARRAY(T) :-
        T == typeOfType(s, t).

    typeOfType(s, TypeListDynamic(t)) = LIST(T) :-
        T == typeOfType(s, t).
    typeOfType(s, TypeListFixedAnonymous(t, size)) = LIST(T) :-
        T == typeOfType(s, t).
    typeOfType(s, TypeListFixedNamed(t, names)) = LIST(T) :-
        T == typeOfType(s, t).

    typeOfType(s, TypeEnum(keys)) =
        typeOfEnum(s, keys).

    typeOfType(s, TypeInterface(membs)) =
        typeOfInterface(s, membs, []).
    typeOfType(s, TypeInterfaceCompose(bases, membs)) =
        typeOfInterface(s, membs, bases).

    typeOfType(_, _) = UNK() :-
        try { false } | note $[todo: other types].

rules

    typeBoolish : TYPE

    typeBoolish(BOOL()).
    typeBoolish(SELECTOR(_)).
    typeBoolish(POS(_, INT())).
    typeBoolish(POS(_, FLOAT())).
    typeBoolish(_) :- false.

rules

    /** resolves to UNK if type is not iterable */
    typeUnwrapIter : TYPE -> TYPE
    typeUnwrapIter(ITER(T)) = T.
    typeUnwrapIter(LIST(T)) = T.
    typeUnwrapIter(ARRAY(T)) = T.
    typeUnwrapIter(T) = UNK().

rules

    destructType : TYPE -> list(TYPE)
    destructType(POS(POS_ABS(), T)) = [T, T, T].
    destructType(t) = [] :- false | error $[cannot destruct type [t]].
