module statics/type/bounds

imports

    statics/common
    statics/bind/field

rules

    /** check if first type is a subtype of the second type (or eq) */
    // TODO: check if all possibilities are defined
    subtype : TYPE * TYPE

    subtype(INT(), FLOAT()).

    // TODO: ensure POS kinds are legal
    subtype(POS(ka, Ta), POS(kb, Tb)) :- subtype(Ta, Tb).
    subtype(RANGE(a), RANGE(b)) :- subtype(a, b).

    subtype(ITER(a), ITER(b)) :- subtype(a, b).

    subtype(COMPOUND(s_comp_a), COMPOUND(s_comp_b)) :- subtypeCompound(s_comp_a, s_comp_b).
    subtype(LIST(a), LIST(b)) :- subtype(a, b).
    subtype(ARRAY(a), ARRAY(b)) :- subtype(a, b).

    subtype(_, UNK()).
    //LAMBDA

    subtype(a, b) :- a == b.

rules

    /** check if the first compound scope is a structural subtype of the second compound scope */
    subtypeCompound : scope * scope

    subtypeCompound(s_comp_a, s_comp_b) :- {allmembs_b}
        // all members of 'b' must be present in 'a' with the 'a' items being a subtype of the corresponding 'b' item,
        // but 'a' may have more members
        allmembs_b == queryAllFields(s_comp_b),
        subtypeCompound_membersOk(s_comp_a, allmembs_b).

    subtypeCompound_membersOk maps subtypeCompound_memberOk(*, list(*))
    subtypeCompound_memberOk : scope * (path * (string * TYPE))
    subtypeCompound_memberOk(s_comp_a, memb_b@(_, (name, Tb))) :- {Ta}
        (_, Ta) == resolveField(s_comp_a, name),
        subtype(Ta, Tb).

rules

    /** derive least upper bound */
    // TODO: check if all possibilities are defined
    lub : TYPE * TYPE -> TYPE

    lub(FLOAT(), INT()) = FLOAT().
    lub(INT(), FLOAT()) = FLOAT().

    //lub(POS(a), POS(b)) :- lub(a, b).
    lub(RANGE(a), RANGE(b)) = RANGE(lub(a, b)).

    lub(ITER(a), ITER(b)) = ITER(lub(a, b)).

    lub(COMPOUND(s_comp_a), COMPOUND(s_comp_b)) = COMPOUND(intersectCompound(s_comp_a, s_comp_b)).
    lub(LIST(a), LIST(b)) = LIST(lub(a, b)).
    lub(ARRAY(a), ARRAY(b)) = ARRAY(lub(a, b)).

    lub(a, UNK()) = a.
    lub(UNK(), b) = b.

    lub(a, b) = a :-
        a == b | error $[no type commonality].

rules

    /** derive least lower bound */
    llb : TYPE * TYPE -> TYPE

    llb(FLOAT(), INT()) = INT().
    llb(INT(), FLOAT()) = INT().

    //llb(POS(a), POS(b)) :- llb(a, b).
    llb(RANGE(a), RANGE(b)) = RANGE(llb(a, b)).

    llb(ITER(a), ITER(b)) = ITER(llb(a, b)).

    llb(COMPOUND(s_comp_a), COMPOUND(s_comp_b)) = COMPOUND(llbCompound([s_comp_a, s_comp_b])).
    llb(LIST(a), LIST(b)) = LIST(llb(a, b)).
    llb(ARRAY(a), ARRAY(b)) = ARRAY(llb(a, b)).

    llb(_, _) = BOTTOM().

rules

    llbCompound : list(scope) -> scope
    llbCompound([]) = s_llbc_anon :- new s_llbc_anon.
    llbCompound([s]) = s.
    llbCompound(ss) = s_llbc :-
        // TODO/LEFTOFF
        /*dummy*/ss == [s_llbc|_].

rules

    intersectCompound : scope * scope -> scope

    // TODO: this is a placeholder implementation
    intersectCompound(s_comp_a, s_comp_b) = s_int :-
        new s_int, s_int -B-> s_comp_a, s_int -B-> s_comp_b.
