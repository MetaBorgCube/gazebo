module statics/statement/cf

imports

    statics/common
    statics/expr
    statics/types
    statics/statement/block
    statics/bind/memb

rules // some VERY NOT NICE rules to do type explosion combined with declaring the members during zipping

    zipSafeLeft_string_TYPE_andDecl : scope * list(string) * list(TYPE) -> list((string * TYPE))
    zipSafeLeft_string_TYPE_andDecl(_, [], _) = [].
    zipSafeLeft_string_TYPE_andDecl(_, x, []) = [] :-
        x == [] | error $[too few items in right list].
    zipSafeLeft_string_TYPE_andDecl(s, [x|xs], [y|ys]) = [(x, y) | zipSafeLeft_string_TYPE_andDecl(s, xs, ys)] :-
        @x.type := y,
        declareMemb(s, x, y).

    typeDestructAssign_andDecl : scope * list(string) * TYPE -> list((string * TYPE))
    typeDestructAssign_andDecl(_, [], _) = [].
    typeDestructAssign_andDecl(s, [x], T) = [(x, T)] :-
        @x.type := T,
        declareMemb(s, x, T).
    typeDestructAssign_andDecl(s, names, Tdestr) = zipped :- {Tdestr'}
        destructType(Tdestr) == Tdestr',
        zipSafeLeft_string_TYPE_andDecl(s, names, Tdestr') == zipped.

rules // for

    forOk : scope * For

    forOk(s, ForInfinite(body)) :- {s_for_inf}
        new s_for_inf, s_for_inf -P-> s,
        blockOk(s_for_inf, body).

    forOk(s, ForWhile(cond, body)) :- {Tc s_for_wh}
        typeOfExpr(s, cond) == Tc,
        typeBoolish(Tc) | error $[condition is not boolish, instead: [Tc]]@cond,
        new s_for_wh, s_for_wh -P-> s,
        blockOk(s_for_wh, body).

    forOk(s, ForIn(names, iter, body)) :- {Ti Telem Tassigned s_for_in}
        typeOfExpr(s, iter) == Ti,
        Telem != UNK() | error $[type [Ti] is not iterable]@iter,
        typeUnwrapIter(Ti) == Telem,
        new s_for_in, s_for_in -P-> s,
        // TODO: ensure the declared members are not marked mutable
        typeDestructAssign_andDecl(s_for_in, names, Telem) == Tassigned,
        blockOk(s_for_in, body).

rules // if

    ifOk : scope * If

    ifOk(s, If(cond, body, else)) :- {Tc s_if}
        try { false } | note $[todo: assert bool type or check coercion]@cond,
        typeOfExpr(s, cond) == Tc,
        typeBoolish(Tc) | error $[condition is not boolish, instead: [Tc]]@cond,

        new s_if, s_if -P-> s,
        blockOk(s_if, body),
        elseOk(s, else).

    elseOk : scope * Else

    elseOk(s, ElseIf(if)) :-
        ifOk(s, if).

    elseOk(s, ElseBlock(body)) :- {s_else}
        new s_else, s_else -P-> s,
        blockOk(s_else, body).

    elseOk(s, NoElse()).

rules // match

    matchOk : scope * Match

    matchOk(s, m@Match(e, cases)) :- {T}
        typeOfExpr(s, e) == T,
        try { false } | note $[subtype check on case expr, enum key scope injection]@e,
        cases != [] | error $[specify at least one case]@m,
        matchCasesOk(s, cases).

    matchCasesOk maps matchCaseOk(*, list(*))

    matchCaseOk : scope * Case

    matchCaseOk(s, Case(e, body)) :- {T s_case}
        typeOfExpr(s, e) == T,
        new s_case, s_case -P-> s,
        try { false } | note $[shadow on ref match]@e,
        blockOk(s_case, body).

rules // return

    returnOk : scope * Return

    returnOk(s, ReturnValue(e)) :- {T}
        try { false } | note $[todo: check type is supertype of expected return type]@e,
        typeOfExpr(s, e) == T.
